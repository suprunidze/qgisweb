<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Роздільник зображень на плитки</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Використання шрифту Montserrat */
        body {
            font-family: 'Montserrat', sans-serif; /* Змінено шрифт */
            background-color: #f0f4f8; /* Легкий сірий фон */
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden; /* Ховаємо загальну прокрутку сторінки */
        }

        /* Стилі для контейнера плиток (viewport) */
        #canvas-container {
            position: absolute; /* Абсолютне позиціонування для заповнення сторінки */
            top: 0;
            left: 0;
            width: 100%; /* Займає всю доступну ширину */
            height: 100vh; /* Займає всю доступну висоту */
            overflow: hidden; /* Приховуємо вміст, що виходить за межі контейнера */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Легка тінь */
            background-color: #e0e0e0; /* Змінено на світло-сірий фон */
            padding: 5px; /* Внутрішній відступ */
            cursor: grab; /* Курсор для перетягування */
            position: relative; /* Необхідно для абсолютно позиціонованого grid-wrapper */
        }

        #canvas-container.dragging {
            cursor: grabbing; /* Курсор при перетягуванні */
        }

        /* Стилі для фонового canvas (розмите зображення) */
        #background-canvas {
            position: absolute; /* Абсолютне позиціонування */
            top: 0;
            left: 0;
            /* width і height будуть встановлені JavaScript відповідно до розміру зображення */
            filter: blur(5px); /* Розмиття фонового зображення */
            opacity: 0; /* Початково прихований, відображається після завантаження контенту */
            z-index: 0; /* Забезпечує, що він знаходиться під grid-wrapper */
            display: block; /* Запобігає зайвим відступам */
            transform-origin: 0 0; /* Точка трансформації завжди верхній лівий кут */
            transition: transform 0.2s ease-in-out, opacity 0.5s ease-in-out; /* Плавна анімація зуму та проявлення */
            background-color: #f0f4f8; /* Колір, якщо зображення не завантажилось */
        }

        #background-canvas.loaded-background {
            opacity: 1; /* Відображається після завантаження основного контенту */
        }

        /* Стилі для фонового канвасу з низькою роздільною здатністю */
        #low-res-background-canvas {
            position: absolute;
            top: 0;
            left: 0;
            filter: none; /* Прибрано розмиття */
            opacity: 0; /* Початково прихований, відображається за допомогою JS */
            z-index: 2; /* Вище за grid-wrapper та background-canvas, коли видимий */
            display: block;
            transform-origin: 0 0;
            transition: transform 0.2s ease-in-out, opacity 0.5s ease-in-out; /* Додано анімацію opacity */
            background-color: #f0f4f8; /* Запасний колір */
        }

        /* Стилі для середньо-роздільного фонового канвасу */
        #mid-res-background-canvas {
            position: absolute;
            top: 0;
            left: 0;
            filter: none; /* Прибрано розмиття */
            opacity: 0; /* Початково прихований, відображається за допомогою JS */
            z-index: 3; /* Вище за low-res та grid-wrapper */
            display: block;
            transform-origin: 0 0;
            transition: transform 0.2s ease-in-out, opacity 0.5s ease-in-out; /* Додано анімацію opacity */
            background-color: #f0f4f8; /* Запасний колір */
        }

        /* Стилі для обгортки сітки (вмісту, що масштабується) */
        #grid-wrapper {
            display: grid; /* Використовуємо CSS Grid для розташування плиток */
            gap: 0px; /* Відстань між плитками 0 пікселів */
            transform-origin: 0 0; /* Точка трансформації завжди верхній лівий кут */
            transition: transform 0.2s ease-in-out, opacity 0.5s ease-in-out; /* Плавна анімація зуму та opacity */
            position: absolute; /* Змінено з relative на absolute */
            top: 0; /* Додано для absolute позиціонування */
            left: 0; /* Додано для absolute позиціонування */
            z-index: 1; /* Забезпечує, що він знаходиться над фоновим canvas */
            /* top, left, width, height будуть встановлені JavaScript */
        }

        /* Стилі для кожного елемента canvas */
        canvas {
            display: block; /* Видаляємо зайвий простір під canvas */
            border: 0; /* Контури плиток прибрано */
            border-radius: 0; /* Закруглені кути для кожної плитки прибрано */
            opacity: 0; /* Початкова прозорість для анімації */
            transition: opacity 0.5s ease-in-out; /* Анімація проявлення */
        }

        /* Клас для відображення плиток після завантаження */
        canvas.loaded {
            opacity: 1;
        }

        /* Стилі для кнопок */
        .zoom-button {
            width: 48px; /* Ширина кнопки за замовчуванням (для тач-пристроїв) */
            height: 48px; /* Висота кнопки за замовчуванням (для тач-пристроїв) */
            border-radius: 50%; /* Закруглені кути (коло) */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* Тінь */
            background-color: #e0e0e0; /* Світло-сірий фон */
            border: none; /* Без рамки */
            cursor: pointer; /* Курсор-вказівник */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease-in-out, width 0.3s ease-in-out, height 0.3s ease-in-out; /* Плавний перехід розмірів */
        }

        .zoom-button:hover {
            background-color: #cccccc; /* Темніший сірий при наведенні */
        }

        /* Змінено: Видалено box-shadow: none; для кнопки при фокусі, щоб тінь зберігалася */
        .zoom-button:focus {
            outline: none; /* Без стандартної рамки фокуса */
            /* box-shadow: none; - ВИДАЛЕНО */
        }

        /* Стилі для іконок всередині кнопок */
        .zoom-button img {
            width: 24px; /* Розмір іконки за замовчуванням */
            height: 24px; /* Розмір іконки за замовчуванням */
        }

        /* Зменшення розміру кнопок та іконок для десктопів */
        @media (hover: hover) and (pointer: fine) {
            .zoom-button {
                width: 36px; /* Зменшена ширина для десктопів */
                height: 36px; /* Зменшена висота для дескропів */
            }
            .zoom-button img {
                width: 18px; /* Зменшення розміру іконки для дескропів */
                height: 18px; /* Зменшення розміру іконки для дескропів */
            }
        }

        /* Стилі для контейнера кнопок */
        #button-controls {
            position: absolute;
            right: 20px; /* Відступ від правого краю */
            top: 50%; /* Центрування по вертикалі */
            transform: translateY(-50%); /* Точне вертикальне центрування */
            display: flex;
            flex-direction: column; /* Вертикальне розташування */
            gap: 15px; /* Відстань між кнопками */
            z-index: 10; /* Щоб кнопки були над контейнером */
        }

        /* Стилі для фонового canvas завантаження */
        #loading-background-canvas {
            position: absolute; /* Відносно canvas-container */
            top: 0;
            left: 0;
            width: 100%; /* Заповнює батьківський контейнер */
            height: 100%; /* Заповнює батьківський контейнер */
            z-index: 50; /* Вище за background-canvas, нижче за grid-wrapper */
            filter: blur(10px); /* Розмиття */
            opacity: 1; /* Початково видимий */
            transition: opacity 0.5s ease-out; /* Плавне зникнення */
            background-color: #f0f4f8; /* Колір, якщо зображення не завантажилось */
        }

        #loading-background-canvas.hide-loading {
            opacity: 0;
            pointer-events: none; /* Вимикаємо взаємодію після приховування */
        }

        /* Стилі для спінера завантаження */
        #loading-spinner {
            z-index: 100; /* Вище за все під час завантаження */
            transition: opacity 0.5s ease-out; /* Плавне зникнення */
        }
        #loading-spinner.hidden {
            opacity: 0;
            pointer-events: none; /* Вимикаємо взаємодію після приховування */
        }

        /* Стилі для анімації спінера */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Стилі для кругового спінера */
        .circular-spinner {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3b82f6; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }

        /* Стилі для випадаючого списку */
        #drawing-selector-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background-color: #ffffff;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #drawing-selector-container label {
            font-size: 1rem;
            color: #333;
            font-weight: 500;
        }

        #drawing-selector {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1rem;
            font-family: 'Montserrat', sans-serif;
            background-color: #f9f9f9;
            cursor: pointer;
            outline: none;
            transition: border-color 0.3s ease;
        }

        #drawing-selector:focus {
            border-color: #3b82f6;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="loading-background-canvas"></canvas>
        <div id="loading-spinner" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background-color: rgba(255, 255, 255, 0.75); z-index: 50; border-radius: 8px;">
            <div class="circular-spinner"></div>
        </div>
        <canvas id="background-canvas"></canvas>
        <canvas id="low-res-background-canvas"></canvas>
        <canvas id="mid-res-background-canvas"></canvas> <div id="grid-wrapper">
        </div>
    </div>

    <div id="button-controls">
        <button id="zoomInBtn" class="zoom-button" aria-label="Збільшити масштаб">
            <img src="https://img.icons8.com/android/48/000000/plus.png" alt="Збільшити">
        </button>
        <button id="zoomOutBtn" class="zoom-button" aria-label="Зменшити масштаб">
            <img src="https://img.icons8.com/material-outlined/48/000000/minus.png" alt="Зменшити">
        </button>
        <button id="homeBtn" class="zoom-button" aria-label="Повернути початкове положення">
            <img src="https://img.icons8.com/material-outlined/48/737373/collapse.png" alt="Додому"> </button>
    </div>

    <div id="drawing-selector-container">
        <label for="drawing-selector">Виберіть план:</label>
        <select id="drawing-selector">
            </select>
    </div>

    <script>
        // Отримання посилань на елементи DOM
        const canvasContainer = document.getElementById('canvas-container');
        const gridWrapper = document.getElementById('grid-wrapper'); // Обгортка для сітки
        const backgroundCanvas = document.getElementById('background-canvas'); // Фоновий canvas для плиток
        const lowResBackgroundCanvas = document.getElementById('low-res-background-canvas'); // Канвас для низької роздільної здатності
        const midResBackgroundCanvas = document.getElementById('mid-res-background-canvas'); // Новий канвас для середньої роздільної здатності
        const loadingBackgroundCanvas = document.getElementById('loading-background-canvas'); // Фоновий canvas для завантаження
        const loadingSpinner = document.getElementById('loading-spinner'); // Спінер завантаження
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const homeBtn = document.getElementById('homeBtn'); // Нова кнопка "Додому"
        const drawingSelector = document.getElementById('drawing-selector'); // Випадаючий список

        let imageUrl = 'https://wgis.project.co.ua/nadpilna/proj.jpg'; // URL зображення (буде оновлюватися)
        const configUrl = 'https://wgis.project.co.ua/nadpilna/config.json'; // URL файлу конфігурації

        const baseTileSize = 400; // Базовий розмір кожної плитки (в пікселях)
        let currentZoomLevel = 1.0; // Початковий рівень масштабування
        const fixedMinZoomLevel = 0.08; // Мінімальний рівень масштабування, щоб не зменшувати надто сильно
        const maxZoomLevel = 2.0; // Максимальний рівень масштабування до 200%
        const zoomStep = 0.25; // Крок зміни масштабу для кнопок
        const mouseZoomFactor = 1.1; // Коефіцієнт зуму для коліщатка миші (Змінено на 1.1)

        let tileData = []; // Масив для зберігання даних про кожну плитку
        let imgGlobal = null; // Зберігаємо зображення після завантаження, щоб не завантажувати його знову
        let observer = null; // Зберігаємо IntersectionObserver

        // Змінні для перетягування (панорамування)
        let isDragging = false;
        let startX, startY; // Початкові координати кліка/дотику
        let currentPanX = 0; // Поточна позиція translateX для gridWrapper
        let currentPanY = 0; // Поточна позиція translateY для gridWrapper
        let initialPanX = 0; // Початкова позиція translateX при початку перетягування
        let initialPanY = 0; // Початкова позиція translateY при початку перетягування

        // Змінні для pinch-to-zoom
        let initialPinchDistance = 0;
        let initialZoomLevel = 1.0;
        let isPinching = false;

        // Флаг для відстеження анімації зуму
        let isAnimatingZoom = false;

        // Поріг масштабування для перемикання між шарами
        const lowResThreshold = 0.25; // 25% zoom level
        const midResThreshold = 0.50; // 50% zoom level

        const lowResCanvasResolutionFactor = 0.25; // Коефіцієнт роздільної здатності для low-res canvas (25%)
        const midResCanvasResolutionFactor = 0.50; // Коефіцієнт роздільної здатності для mid-res canvas (50%)


        // Функція для малювання плитки на canvas
        function drawTile(canvas, img, sx, sy, sWidth, sHeight) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Очищаємо перед малюванням
            ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
            canvas.classList.add('loaded'); // Додаємо клас для анімації проявлення
        }

        // Функція для малювання розмитого фонового зображення для плиток (прив'язаний до контенту)
        function drawBackgroundCanvas(img) {
            // Встановлюємо розміри фонового canvas відповідно до розмірів оригінального зображення
            backgroundCanvas.width = img.width;
            backgroundCanvas.height = img.height;

            const ctx = backgroundCanvas.getContext('2d');
            ctx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height); // Очищаємо canvas
            ctx.drawImage(img, 0, 0); // Малюємо оригінальне зображення на canvas
            // CSS filter: blur(5px) застосовується автоматично
        }

        // Функція для малювання розмитого фонового зображення для екрану завантаження (на весь екран)
        function drawLoadingBackground(img) {
            // Розміри канвасу завантаження відповідають розмірам контейнера
            loadingBackgroundCanvas.width = canvasContainer.clientWidth;
            loadingBackgroundCanvas.height = canvasContainer.clientHeight;

            const ctx = loadingBackgroundCanvas.getContext('2d');
            ctx.clearRect(0, 0, loadingBackgroundCanvas.width, loadingBackgroundCanvas.height);

            if (!img || img.naturalWidth === 0) {
                // Якщо зображення ще не завантажено або порожнє, малюємо просто фон
                ctx.fillStyle = '#f0f4f8';
                ctx.fillRect(0, 0, loadingBackgroundCanvas.width, loadingBackgroundCanvas.height);
                return;
            }

            const canvasWidth = loadingBackgroundCanvas.width;
            const canvasHeight = loadingBackgroundCanvas.height;
            const imgAspect = img.naturalWidth / img.naturalHeight;
            const canvasAspect = canvasWidth / canvasHeight;

            let drawWidth, drawHeight, offsetX, offsetY;

            // Calculate to cover the canvas (aspect-ratio-preserving)
            if (imgAspect > canvasAspect) {
                // Image is wider than canvas, fit by height and crop width
                drawHeight = canvasHeight;
                drawWidth = canvasHeight * imgAspect;
                offsetX = (canvasWidth - drawWidth) / 2;
                offsetY = 0;
            } else {
                // Image is taller than canvas, fit by width and crop height
                drawWidth = canvasWidth;
                drawHeight = canvasWidth / imgAspect;
                offsetY = (canvasHeight - drawHeight) / 2;
                offsetX = 0;
            }

            ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, offsetX, offsetY, drawWidth, drawHeight);
            // CSS filter blur is applied via CSS
        }

        // Функція для малювання фонового канвасу з низькою роздільною здатністю
        function drawLowResBackgroundCanvas(img) {
            const scaledWidth = img.width * lowResCanvasResolutionFactor;
            const scaledHeight = img.height * lowResCanvasResolutionFactor;

            lowResBackgroundCanvas.width = scaledWidth;
            lowResBackgroundCanvas.height = scaledHeight;

            const ctx = lowResBackgroundCanvas.getContext('2d');
            ctx.clearRect(0, 0, lowResBackgroundCanvas.width, lowResBackgroundCanvas.height);
            ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, scaledWidth, scaledHeight);
        }

        // Функція для малювання фонового канвасу з середньою роздільною здатністю
        function drawMidResBackgroundCanvas(img) {
            const scaledWidth = img.width * midResCanvasResolutionFactor;
            const scaledHeight = img.height * midResCanvasResolutionFactor;

            midResBackgroundCanvas.width = scaledWidth;
            midResBackgroundCanvas.height = scaledHeight;

            const ctx = midResBackgroundCanvas.getContext('2d');
            ctx.clearRect(0, 0, midResBackgroundCanvas.width, midResBackgroundCanvas.height);
            ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, scaledWidth, scaledHeight);
        }

        // Функція для завантаження та обробки зображення
        function processImage() {
            // Очищаємо обгортку сітки перед перемальовуванням
            gridWrapper.innerHTML = '';
            tileData = []; // Очищаємо дані про плитки

            // Відключаємо старий observer, якщо він існує
            if (observer) {
                observer.disconnect();
            }

            // Показуємо спінер завантаження
            loadingSpinner.classList.remove('hidden');

            // Малюємо початковий фон завантаження (пустий або з плейсхолдером)
            drawLoadingBackground(null); // Малюємо порожній фон завантаження

            const img = new Image();
            img.crossOrigin = 'Anonymous'; // Важливо для завантаження зображень з інших доменів

            img.onload = () => {
                imgGlobal = img; // Зберігаємо зображення для подальшого використання
                
                calculateInitialZoomAndPan(img); // Обчислюємо початковий зум та панорамування
                drawBackgroundCanvas(imgGlobal); // Малюємо розмитий фон для плиток (висока роздільна здатність)
                drawLowResBackgroundCanvas(imgGlobal); // Малюємо фон низької роздільної здатності
                drawMidResBackgroundCanvas(imgGlobal); // Малюємо фон середньої роздільної здатності
                drawLoadingBackground(imgGlobal); // Оновлюємо фон завантаження з зображенням

                // Приховуємо фоновий canvas завантаження та спінер
                loadingBackgroundCanvas.classList.add('hide-loading');
                loadingSpinner.classList.add('hidden');
                // Видимість основного контенту (плиток/фону низької роздільної здатності) буде встановлена в applyTransform
            };

            img.onerror = () => {
                console.error('Помилка завантаження зображення:', imageUrl);
                // Приховуємо фоновий canvas завантаження та спінер, якщо сталася помилка
                loadingBackgroundCanvas.classList.add('hide-loading');
                loadingSpinner.classList.add('hidden');
            };

            img.src = imageUrl; // Встановлення джерела зображення
        }

        // Функція для обчислення початкового зуму та панорамування
        function calculateInitialZoomAndPan(img) {
            const imgWidth = img.width;
            const imgHeight = img.height;

            // Розрахунок кількості плиток по ширині та висоті
            const cols = Math.ceil(imgWidth / baseTileSize);
            const rows = Math.ceil(imgHeight / baseTileSize);

            // Визначення розмірів всього блоку плиток без масштабування
            const totalGridWidth = cols * baseTileSize;
            const totalGridHeight = rows * baseTileSize;

            // Отримання видимих розмірів контейнера (з урахуванням padding)
            const viewportWidth = canvasContainer.clientWidth;
            const viewportHeight = canvasContainer.clientHeight;

            // Розрахунок масштабу, щоб зображення вписалося в контейнер
            let fitScaleX = viewportWidth / totalGridWidth;
            let fitScaleY = viewportHeight / totalGridHeight;
            let calculatedMinZoom = Math.min(fitScaleX, fitScaleY);

            // Встановлюємо currentZoomLevel. Він буде або розрахованим мінімальним,
            // або fixedMinZoomLevel, або maxZoomLevel, якщо розрахований занадто великий.
            currentZoomLevel = Math.max(fixedMinZoomLevel, calculatedMinZoom);
            currentZoomLevel = Math.min(currentZoomLevel, maxZoomLevel);

            // Обчислюємо початкові координати для центрування
            currentPanX = (viewportWidth - totalGridWidth * currentZoomLevel) / 2;
            currentPanY = (viewportHeight - totalGridHeight * currentZoomLevel) / 2;

            renderTiles(img); // Рендеримо плитки з новим масштабом
            applyTransform(currentZoomLevel, currentPanX, currentPanY); // Застосовуємо зум та панорамування, що також керує видимістю
        }


        // Функція для рендерингу плиток
        function renderTiles(img) {
            const imgWidth = img.width;
            const imgHeight = img.height;

            // Розрахунок кількості плиток по ширині та висоті
            const cols = Math.ceil(imgWidth / baseTileSize);
            const rows = Math.ceil(imgHeight / baseTileSize);

            // Відключаємо старий observer перед очищенням DOM
            if (observer) {
                observer.disconnect();
            }

            // Очищаємо обгортку сітки перед перемальовуванням
            gridWrapper.innerHTML = '';
            tileData = []; // Очищаємо дані про плитки

            // Встановлення розмірів обгортки сітки
            gridWrapper.style.gridTemplateColumns = `repeat(${cols}, ${baseTileSize}px)`;
            gridWrapper.style.gridTemplateRows = `repeat(${rows}, ${baseTileSize}px)`;

            // Встановлення розмірів gridWrapper, щоб він мав правильні розміри для масштабування
            gridWrapper.style.width = `${cols * baseTileSize}px`;
            gridWrapper.style.height = `${rows * baseTileSize}px`;

            // Створення Intersection Observer для лінивого завантаження
            observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Плитка увійшла у видиму область
                        const canvas = entry.target;
                        const index = parseInt(canvas.dataset.index);
                        const data = tileData[index];
                        if (data && !canvas.classList.contains('loaded')) {
                            canvas.width = baseTileSize; // Встановлюємо актуальний розмір плитки
                            canvas.height = baseTileSize; // Встановлюємо актуальний розмір плитки
                            drawTile(canvas, img, data.sx, data.sy, data.sWidth, data.sHeight);
                        }
                    } else {
                        // Плитка вийшла з видимої області, скидаємо її стан, щоб вона знову проявилася при поверненні
                        const canvas = entry.target;
                        canvas.classList.remove('loaded');
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height); // Очищаємо canvas
                    }
                });
            }, {
                root: canvasContainer, // Контейнер, який є видимим вікном
                rootMargin: '0px', // Відступ навколо кореневого елемента
                threshold: 0 // Спрацьовує, коли 0% елемента видно (тобто, як тільки з'являється)
            });

            // Створення та додавання canvas для кожної плитки
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = baseTileSize; // Встановлюємо актуальний розмір плитки
                    canvas.height = baseTileSize; // Встановлюємо актуальний розмір плитки
                    canvas.dataset.index = tileData.length; // Зберігаємо індекс для доступу до даних

                    // Обчислення координат для вирізання частини зображення
                    const sx = c * baseTileSize;
                    const sy = r * baseTileSize;
                    const sWidth = Math.min(baseTileSize, imgWidth - sx);
                    const sHeight = Math.min(baseTileSize, imgHeight - sy);

                    // Зберігаємо дані для малювання
                    tileData.push({ sx, sy, sWidth, sHeight });

                    gridWrapper.appendChild(canvas); // Додаємо canvas до обгортки сітки
                    observer.observe(canvas); // Починаємо спостерігати за новою плиткою
                }
            }
        }

        // Функція для оновлення відображення масштабу (тепер виводить в консоль)
        function updateZoomDisplay() {
            console.log(`Масштаб: ${Math.round(currentZoomLevel * 100)}%`);
            console.log(`Позиція (X, Y): (${currentPanX.toFixed(2)}px, ${currentPanY.toFixed(2)}px)`);
        }

        // Функція для застосування transform (scale та translate) до gridWrapper, backgroundCanvas та lowResBackgroundCanvas
        function applyTransform(zoom, panX, panY) {
            const transformStringGrid = `translate(${panX}px, ${panY}px) scale(${zoom})`;

            // Завжди оновлюємо трансформацію для всіх шарів, незалежно від їх видимості
            const lowResScale = zoom / lowResCanvasResolutionFactor;
            lowResBackgroundCanvas.style.transform = `translate(${panX}px, ${panY}px) scale(${lowResScale})`;

            const midResScale = zoom / midResCanvasResolutionFactor;
            midResBackgroundCanvas.style.transform = `translate(${panX}px, ${panY}px) scale(${midResScale})`;

            gridWrapper.style.transform = transformStringGrid;
            backgroundCanvas.style.transform = transformStringGrid;


            if (zoom < lowResThreshold) {
                // Показуємо фон низької роздільної здатності
                lowResBackgroundCanvas.style.opacity = 1;
                lowResBackgroundCanvas.style.pointerEvents = 'auto';

                midResBackgroundCanvas.style.opacity = 0; // Приховуємо середню роздільну здатність
                midResBackgroundCanvas.style.pointerEvents = 'none';

                backgroundCanvas.style.opacity = 0; // Приховуємо високу роздільну здатність
                backgroundCanvas.style.pointerEvents = 'none';

                gridWrapper.style.opacity = 0; // Приховуємо плитки
                gridWrapper.style.pointerEvents = 'none';
            } else if (zoom >= lowResThreshold && zoom < midResThreshold) {
                // Показуємо фон середньої роздільної здатності
                lowResBackgroundCanvas.style.opacity = 0; // Приховуємо низьку роздільну здатність
                lowResBackgroundCanvas.style.pointerEvents = 'none';

                midResBackgroundCanvas.style.opacity = 1;
                midResBackgroundCanvas.style.pointerEvents = 'auto';

                backgroundCanvas.style.opacity = 0; // Приховуємо високу роздільну здатність
                backgroundCanvas.style.pointerEvents = 'none';

                gridWrapper.style.opacity = 0; // Приховуємо плитки
                gridWrapper.style.pointerEvents = 'none';
            } else { // zoom >= midResThreshold
                // Показуємо плитки та фон високої роздільної здатності
                lowResBackgroundCanvas.style.opacity = 0; // Приховуємо низьку роздільну здатність
                lowResBackgroundCanvas.style.pointerEvents = 'none';

                midResBackgroundCanvas.style.opacity = 0; // Приховуємо середню роздільну здатність
                midResBackgroundCanvas.style.pointerEvents = 'none';

                backgroundCanvas.style.opacity = 1;
                backgroundCanvas.style.pointerEvents = 'none';

                gridWrapper.style.opacity = 1;
                gridWrapper.style.pointerEvents = 'auto';
            }
            updateZoomDisplay();
        }

        // Функція для застосування зуму та коригування панорамування
        function handleZoom(newZoom, zoomCenterX = null, zoomCenterY = null) {
            const oldZoom = currentZoomLevel;
            currentZoomLevel = Math.max(fixedMinZoomLevel, Math.min(maxZoomLevel, newZoom));

            if (oldZoom === currentZoomLevel) {
                return;
            }

            const viewportRect = canvasContainer.getBoundingClientRect();
            const viewportWidth = viewportRect.width;
            const viewportHeight = viewportRect.height;

            let contentCenterX, contentCenterY;

            if (zoomCenterX !== null && zoomCenterY !== null) {
                // Масштабування навколо конкретної точки (курсор миші або центр pinch-жесту)
                // Перетворюємо координати області перегляду в координати вмісту до нового масштабу
                contentCenterX = (zoomCenterX - currentPanX) / oldZoom;
                contentCenterY = (zoomCenterY - currentPanY) / oldZoom;
            } else {
                // Масштабування навколо центру області перегляду (для кнопок)
                contentCenterX = (viewportWidth / 2 - currentPanX) / oldZoom;
                contentCenterY = (viewportHeight / 2 - currentPanY) / oldZoom;
            }

            // Обчислюємо нове панорамування на основі центру вмісту та нового рівня масштабу
            currentPanX = (zoomCenterX !== null ? zoomCenterX : viewportWidth / 2) - (contentCenterX * currentZoomLevel);
            currentPanY = (zoomCenterY !== null ? zoomCenterY : viewportHeight / 2) - (contentCenterY * currentZoomLevel);

            applyTransform(currentZoomLevel, currentPanX, currentPanY);

            // Перемальовуємо видимі плитки, якщо вони мають бути видимими
            if (observer && imgGlobal && currentZoomLevel >= midResThreshold) { // Змінено поріг для перемальовування плиток
                gridWrapper.querySelectorAll('canvas').forEach(canvas => {
                    const index = parseInt(canvas.dataset.index);
                    const data = tileData[index];
                    const rect = canvas.getBoundingClientRect();
                    const containerRect = canvasContainer.getBoundingClientRect();
                    if (rect.top < containerRect.bottom && rect.bottom > containerRect.top &&
                        rect.left < containerRect.right && rect.right > containerRect.left) {
                        drawTile(canvas, imgGlobal, data.sx, data.sy, data.sWidth, data.sHeight);
                    }
                });
            }
        }

        // Функція для повернення до початкового положення та розміру (zoom to fit)
        function resetView() {
            if (imgGlobal) {
                console.log('Кнопка "Додому" натиснута. Виконання "zoom to fit"...');
                calculateInitialZoomAndPan(imgGlobal); // Ця функція вже виконує "zoom to fit" і викликає applyTransform
            }
        }

        // Обробники подій для збільшення зуму (повернуто до кліку)
        zoomInBtn.addEventListener('click', () => {
            handleZoom(currentZoomLevel + zoomStep);
        });

        // Обробники подій для зменшення зуму (повернуто до кліку)
        zoomOutBtn.addEventListener('click', () => {
            handleZoom(currentZoomLevel - zoomStep);
        });

        // Додаємо обробник подій для кнопки "Додому"
        homeBtn.addEventListener('click', resetView);

        // Обробник подій для зуму коліщатком миші
        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault(); // Запобігаємо прокручуванню сторінки

            // Якщо йде анімація зуму, ігноруємо подальші події колеса
            if (isAnimatingZoom) {
                return;
            }

            const delta = Math.sign(e.deltaY); // -1 для збільшення, 1 для зменшення
            let newZoom;

            if (delta === -1) { // Збільшення
                newZoom = currentZoomLevel * mouseZoomFactor;
            } else { // Зменшення
                newZoom = currentZoomLevel / mouseZoomFactor;
            }

            // Отримуємо позицію миші відносно canvasContainer
            const rect = canvasContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Зберігаємо оригінальні переходи
            const originalGridTransition = gridWrapper.style.transition;
            const originalBackgroundTransition = backgroundCanvas.style.transition;
            const originalLowResBackgroundTransition = lowResBackgroundCanvas.style.transition;
            const originalMidResBackgroundTransition = midResBackgroundCanvas.style.transition;


            // Застосовуємо швидші переходи для transform, зберігаючи переходи opacity
            gridWrapper.style.transition = 'transform 0.05s ease-out, opacity 0.5s ease-in-out';
            backgroundCanvas.style.transition = 'transform 0.05s ease-out, opacity 0.5s ease-in-out';
            lowResBackgroundCanvas.style.transition = 'transform 0.05s ease-out, opacity 0.5s ease-in-out';
            midResBackgroundCanvas.style.transition = 'transform 0.05s ease-out, opacity 0.5s ease-in-out';

            // Встановлюємо флаг, що анімація зуму активна
            isAnimatingZoom = true;

            handleZoom(newZoom, mouseX, mouseY);

            // Скидаємо переходи та флаг після невеликої затримки
            setTimeout(() => {
                gridWrapper.style.transition = originalGridTransition;
                backgroundCanvas.style.transition = originalBackgroundTransition;
                lowResBackgroundCanvas.style.transition = originalLowResBackgroundTransition;
                midResBackgroundCanvas.style.transition = originalMidResBackgroundTransition;
                isAnimatingZoom = false; // Анімація завершена, дозволяємо перетягування
            }, 60); // Трохи довше, ніж 0.05с, щоб перехід завершився
        });

        // Обробники подій для перетягування
        canvasContainer.addEventListener('mousedown', (e) => {
            // Запобігаємо перетягуванню, якщо йде анімація зуму
            if (isAnimatingZoom) {
                return;
            }
            isDragging = true;
            canvasContainer.classList.add('dragging');
            startX = e.clientX;
            startY = e.clientY;
            initialPanX = currentPanX; // Зберігаємо поточну позицію gridWrapper
            initialPanY = currentPanY;
            gridWrapper.style.transition = 'none'; // Вимикаємо перехід під час перетягування
            backgroundCanvas.style.transition = 'none'; // Вимикаємо перехід для фонового canvas
            lowResBackgroundCanvas.style.transition = 'none'; // Вимикаємо перехід для low-res canvas
            midResBackgroundCanvas.style.transition = 'none'; // Вимикаємо перехід для mid-res canvas
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;

            currentPanX = initialPanX + dx;
            currentPanY = initialPanY + dy;
            applyTransform(currentZoomLevel, currentPanX, currentPanY); // Застосовуємо transform
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            canvasContainer.classList.remove('dragging');
            gridWrapper.style.transition = ''; // Повертаємося до CSS-визначеного переходу
            backgroundCanvas.style.transition = ''; // Повертаємося до CSS-визначеного переходу
            lowResBackgroundCanvas.style.transition = ''; // Повертаємося до CSS-визначеного переходу
            midResBackgroundCanvas.style.transition = ''; // Повертаємося до CSS-визначеного переходу
            // Після завершення перетягування, перемальовуємо видимі плитки
            if (observer && imgGlobal && currentZoomLevel >= midResThreshold) {
                gridWrapper.querySelectorAll('canvas').forEach(canvas => {
                    const index = parseInt(canvas.dataset.index);
                    const data = tileData[index];
                    const rect = canvas.getBoundingClientRect();
                    const containerRect = canvasContainer.getBoundingClientRect();
                    if (rect.top < containerRect.bottom && rect.bottom > containerRect.top &&
                        rect.left < containerRect.right && rect.right > containerRect.left) {
                        drawTile(canvas, imgGlobal, data.sx, data.sy, data.sWidth, data.sHeight);
                    }
                });
            }
        });

        // Обробники подій для тач-скрінів (мобільні пристрої)
        canvasContainer.addEventListener('touchstart', (e) => {
            // Запобігаємо перетягуванню, якщо йде анімація зуму
            if (isAnimatingZoom) {
                return;
            }

            if (e.touches.length === 2) {
                isDragging = false; // Вимикаємо перетягування одним пальцем, якщо починається pinch-to-zoom
                isPinching = true;
                e.preventDefault(); // Запобігаємо стандартній поведінці браузера

                const touch1 = e.touches[0];
                const touch2 = e.touches[1];

                initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                
                // Зберігаємо початковий пан і зум для розрахунків pinch
                initialPanX = currentPanX;
                initialPanY = currentPanY;
                initialZoomLevel = currentZoomLevel;

                gridWrapper.style.transition = 'none'; // Вимикаємо перехід під час pinch
                backgroundCanvas.style.transition = 'none'; // Вимикаємо перехід для фонового canvas
                lowResBackgroundCanvas.style.transition = 'none'; // Вимикаємо перехід для low-res canvas
                midResBackgroundCanvas.style.transition = 'none'; // Вимикаємо перехід для mid-res canvas
            } else if (e.touches.length === 1) {
                isDragging = true;
                canvasContainer.classList.add('dragging');
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                initialPanX = currentPanX;
                initialPanY = currentPanY;
                gridWrapper.style.transition = 'none'; // Вимикаємо перехід під час перетягування
                backgroundCanvas.style.transition = 'none'; // Вимикаємо перехід для фонового canvas
                lowResBackgroundCanvas.style.transition = 'none'; // Вимикаємо перехід для low-res canvas
                midResBackgroundCanvas.style.transition = 'none'; // Вимикаємо перехід для mid-res canvas
            }
        }, { passive: false });

        canvasContainer.addEventListener('touchmove', (e) => {
            if (isPinching && e.touches.length === 2) {
                e.preventDefault(); // Запобігаємо стандартній поведінці браузера

                const touch1 = e.touches[0];
                const touch2 = e.touches[1];

                const currentPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                const scaleFactor = currentPinchDistance / initialPinchDistance;

                let newZoom = initialZoomLevel * scaleFactor;
                newZoom = Math.max(fixedMinZoomLevel, Math.min(maxZoomLevel, newZoom));

                // Обчислюємо поточний центр pinch-жесту відносно області перегляду
                const currentPinchMidpointX = (touch1.clientX + touch2.clientX) / 2;
                const currentPinchMidpointY = (touch1.clientY + touch2.clientY) / 2;

                // Отримуємо позицію canvasContainer
                const rect = canvasContainer.getBoundingClientRect();
                const zoomCenterX = currentPinchMidpointX - rect.left;
                const zoomCenterY = currentPinchMidpointY - rect.top;

                // Коригуємо панорамування, щоб центр pinch-жесту залишався в тому ж відносному положенні
                const oldContentX = (zoomCenterX - initialPanX) / initialZoomLevel;
                const oldContentY = (zoomCenterY - initialPanY) / initialZoomLevel;

                currentPanX = zoomCenterX - (oldContentX * newZoom);
                currentPanY = zoomCenterY - (oldContentY * newZoom);
                currentZoomLevel = newZoom; // Оновлюємо currentZoomLevel для наступної ітерації

                applyTransform(currentZoomLevel, currentPanX, currentPanY);

                // Перемальовуємо видимі плитки
                if (observer && imgGlobal && currentZoomLevel >= midResThreshold) {
                    gridWrapper.querySelectorAll('canvas').forEach(canvas => {
                        const index = parseInt(canvas.dataset.index);
                        const data = tileData[index];
                        const rect = canvas.getBoundingClientRect();
                        const containerRect = canvasContainer.getBoundingClientRect();
                        if (rect.top < containerRect.bottom && rect.bottom > containerRect.top &&
                            rect.left < containerRect.right && rect.right > containerRect.left) {
                            drawTile(canvas, imgGlobal, data.sx, data.sy, data.sWidth, data.sHeight);
                        }
                    });
                }

            } else if (isDragging && e.touches.length === 1) {
                e.preventDefault();
                const dx = e.touches[0].clientX - startX;
                const dy = e.touches[0].clientY - startY;

                currentPanX = initialPanX + dx;
                currentPanY = initialPanY + dy;
                applyTransform(currentZoomLevel, currentPanX, currentPanY); // Застосовуємо transform
            }
        }, { passive: false });

        canvasContainer.addEventListener('touchend', () => {
            isDragging = false;
            isPinching = false;
            canvasContainer.classList.remove('dragging');
            gridWrapper.style.transition = ''; // Повертаємося до CSS-визначеного переходу
            backgroundCanvas.style.transition = ''; // Повертаємося до CSS-визначеного переходу
            lowResBackgroundCanvas.style.transition = ''; // Повертаємося до CSS-визначеного переходу
            midResBackgroundCanvas.style.transition = ''; // Повертаємося до CSS-визначеного переходу
            // Після завершення перетягування, перемальовуємо видимі плитки
            if (observer && imgGlobal && currentZoomLevel >= midResThreshold) {
                gridWrapper.querySelectorAll('canvas').forEach(canvas => {
                    const index = parseInt(canvas.dataset.index);
                    const data = tileData[index];
                    const rect = canvas.getBoundingClientRect();
                    const containerRect = canvasContainer.getBoundingClientRect();
                    if (rect.top < containerRect.bottom && rect.bottom > containerRect.top &&
                        rect.left < containerRect.right && rect.right > containerRect.left) {
                        drawTile(canvas, imgGlobal, data.sx, data.sy, data.sWidth, data.sHeight);
                    }
                });
            }
        });

        // Функція для завантаження даних про креслення з config.json та заповнення випадаючого списку
        async function loadDrawings() {
            try {
                const response = await fetch(configUrl);
                const config = await response.json();
                if (config && config.drawings && Array.isArray(config.drawings)) {
                    drawingSelector.innerHTML = ''; // Очищаємо існуючі опції
                    config.drawings.forEach(drawing => {
                        const option = document.createElement('option');
                        option.value = drawing.url;
                        option.textContent = drawing.name;
                        drawingSelector.appendChild(option);
                    });
                    // Встановлюємо початкове зображення на перше з конфігурації, якщо є
                    if (config.drawings.length > 0) {
                        imageUrl = config.drawings[0].url;
                        processImage(); // Завантажуємо перше зображення
                    }
                }
            } catch (error) {
                console.error('Помилка завантаження конфігурації креслень:', error);
            }
        }

        // Обробник подій для зміни вибору у випадаючому списку
        drawingSelector.addEventListener('change', (e) => {
            imageUrl = e.target.value; // Оновлюємо URL зображення
            processImage(); // Перезавантажуємо зображення
        });


        // Запуск обробки зображення після завантаження DOM
        document.addEventListener('DOMContentLoaded', () => {
            loadDrawings(); // Завантажуємо креслення при завантаженні DOM
        });

        // Додаємо обробник події resize для перерахунку початкового зуму та центрування
        window.addEventListener('resize', () => {
            if (imgGlobal) {
                calculateInitialZoomAndPan(imgGlobal);
                // Оновлюємо фон завантаження при зміні розміру вікна, якщо він ще видимий
                if (!loadingBackgroundCanvas.classList.contains('hide-loading')) {
                    drawLoadingBackground(imgGlobal);
                }
            }
        });
    </script>
</body>
</html>
