<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Роздільник зображень на плитки</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Використання шрифту Montserrat */
        body {
            font-family: 'Montserrat', sans-serif; /* Змінено шрифт */
            background-color: #f0f4f8; /* Легкий сірий фон */
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden; /* Ховаємо загальну прокрутку сторінки */
        }

        /* Стилі для контейнера плиток (viewport) */
        #canvas-container {
            position: absolute; /* Абсолютне позиціонування для заповнення сторінки */
            top: 56px; /* Змінено: 56px від верхнього краю */
            left: 0;
            width: 100%; /* Займає всю доступну ширину */
            height: calc(100dvh - 56px); /* Змінено: Висота збільшена на 56px, щоб компенсувати від'ємний top */
            overflow: hidden; /* Приховуємо вміст, що виходить за межі контейнера */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* Легка тінь */
            background-color: #e0e0e0; /* Змінено на світло-сірий фон */
            padding: 5px; /* Внутрішній відступ */
            cursor: grab; /* Курсор для перетягування */
            position: relative; /* Необхідно для абсолютно позиціонованого grid-wrapper */
            transition: width 0.3s ease-out; /* Додано: Плавна зміна ширини */
        }

        #canvas-container.dragging {
            cursor: grabbing; /* Курсор при перетягування */
        }

        /* Стилі для фонового canvas (розмите зображення) */
        #background-canvas {
            position: absolute; /* Абсолютне позиціонування */
            top: 0;
            left: 0;
            /* width і height будуть встановлені JavaScript відповідно до розміру зображення */
            filter: blur(5px); /* Розмиття фонового зображення */
            opacity: 0; /* Початково прихований, відображається після завантаження контенту */
            z-index: 0; /* Забезпечує, що він знаходиться під grid-wrapper */
            display: block; /* Запобігає зайвим відступам */
            transform-origin: 0 0; /* Точка трансформації завжди верхній лівий кут */
            transition: transform 0.3s ease-out, opacity 0.5s ease-in-out; /* Повернуто до стандартної анімації */
            background-color: #f0f4f8; /* Колір, якщо зображення не завантажилось */
        }

        #background-canvas.loaded-background {
            opacity: 1; /* Відображається після завантаження основного контенту */
        }

        /* Стилі для фонового канвасу з низькою роздільною здатністю */
        #low-res-background-canvas {
            position: absolute;
            top: 0;
            left: 0;
            filter: none; /* Прибрано розмиття */
            opacity: 0; /* Початково прихований, відображається за допомогою JS */
            z-index: 2; /* Вище за grid-wrapper та background-canvas, коли видимий */
            display: block;
            transform-origin: 0 0;
            transition: transform 0.3s ease-out, opacity 0.5s ease-in-out; /* Повернуто до стандартної анімації */
            background-color: #f0f4f8; /* Запасний колір */
        }

        /* Стилі для середньо-роздільного фонового канвасу */
        #mid-res-background-canvas {
            position: absolute;
            top: 0;
            left: 0;
            filter: none; /* Прибрано розмиття */
            opacity: 0; /* Початково прихований, відображається за допомогою JS */
            z-index: 3; /* Вище за low-res та grid-wrapper */
            display: block;
            transform-origin: 0 0;
            transition: transform 0.3s ease-out, opacity 0.5s ease-in-out; /* Повернуто до стандартної анімації */
            background-color: #f0f4f8; /* Запасний колір */
        }

        /* Стилі для обгортки сітки (вмісту, що масштабується) */
        #grid-wrapper {
            display: grid; /* Використовуємо CSS Grid для розташування плиток */
            gap: 0px; /* Відстань між плитками 0 пікселів */
            transform-origin: 0 0; /* Точка трансформації завжди верхній лівий кут */
            transition: transform 0.3s ease-out, opacity 0.5s ease-in-out; /* Повернуто до стандартної анімації */
            position: absolute; /* Змінено з relative на absolute */
            top: 0; /* Додано для absolute позиціонування */
            left: 0; /* Додано для absolute позиціонування */
            z-index: 1; /* Забезпечує, що він знаходиться над фоновим canvas */
            /* top, left, width, height будуть встановлені JavaScript */
        }

        /* Стилі для кожного елемента canvas */
        canvas {
            display: block; /* Видаляємо зайвий простір під canvas */
            border: 0; /* Контури плиток прибрано */
            border-radius: 0; /* Закруглені кути для кожної плитки прибрано */
            opacity: 0; /* Початкова прозорість для анімації */
            transition: opacity 0.5s ease-in-out; /* Анімація проявлення */
        }

        /* Клас для відображення плиток після завантаження */
        canvas.loaded {
            opacity: 1;
        }

        /* Клас для тимчасового вимкнення переходів */
        .no-transition {
            transition: none !important;
        }

        /* Стилі для кнопок */
        .zoom-button {
            width: 48px; /* Ширина кнопки за замовчуванням (для тач-пристроїв) */
            height: 48px; /* Висота кнопки за замовчуванням (для тач-пристроїв) */
            border-radius: 50%; /* Закруглені кути (коло) */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* Тінь */
            background-color: #e0e0e0; /* Світло-сірий фон */
            border: none; /* Без рамки */
            cursor: pointer; /* Курсор-вказівник */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease-in-out, width 0.3s ease-in-out, height 0.3s ease-in-out, opacity 0.3s ease-in-out; /* Плавний перехід розмірів та прозорості */
        }

        .zoom-button:hover:not(.disabled) { /* Застосовуємо hover тільки якщо кнопка не disabled */
            background-color: #cccccc; /* Темніший сірий при наведенні */
        }

        /* Стилі для неактивних кнопок */
        .zoom-button.disabled {
            opacity: 0.5; /* Зменшена прозорість */
            cursor: default; /* Змінено: Курсор за замовчуванням */
            box-shadow: none; /* Прибираємо тінь для неактивних кнопок */
            background-color: #f0f0f0; /* Світліший фон */
        }

        /* Змінено: Видалено box-shadow: none; для кнопки при фокусі, щоб тінь зберігалася */
        .zoom-button:focus {
            outline: none; /* Без стандартної рамки фокуса */
            /* box-shadow: none; - ВИДАЛЕНО */
        }

        /* Стилі для іконок всередині кнопок */
        .zoom-button img {
            width: 24px; /* Розмір іконки за замовчуванням */
            height: 24px; /* Розмір іконки за замовчуванням */
        }

        /* Зменшення розміру кнопок та іконок для десктопів */
        @media (min-width: 769px) { /* Desktop styles */
            .zoom-button {
                width: 36px; /* Зменшена ширина для десктопів */
                height: 36px; /* Зменшена висота для десктопів */
            }
            .zoom-button img {
                width: 18px; /* Зменшення розміру іконки для дескропів */
                height: 18px; /* Зменшення розміру іконки для дескропів */
            }
        }

        /* Стилі для контейнера кнопок */
        #button-controls {
            position: absolute;
            right: 20px; /* Відступ від правого краю */
            top: 50%; /* Центрування по вертикалі */
            transform: translateY(-50%); /* Точне вертикальне центрування */
            display: flex;
            flex-direction: column; /* Вертикальне розташування */
            gap: 15px; /* Відстань між кнопками */
            z-index: 10; /* Щоб кнопки були над контейнером */
            transition: right 0.3s ease-out, transform 0.3s ease-out; /* Плавна зміна позиції */
        }

        /* New styles for zoomModeBtn */
        #zoomModeBtn {
            display: none; /* Hidden by default, shown by JS on mobile */
            width: 48px;
            height: 48px;
            border-radius: 50%;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            background-color: #e0e0e0;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease-in-out;
        }

        #zoomModeBtn:hover {
            background-color: #cccccc;
        }

        #zoomModeBtn img {
            width: 24px;
            height: 24px;
        }

        /* Container for expanded zoom buttons */
        #zoom-controls-expanded {
            display: flex;
            flex-direction: column; /* Default for desktop */
            gap: 15px;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        /* Mobile-specific styles for button-controls and zoom-controls-expanded */
        @media (max-width: 768px) { /* Mobile breakpoint */
            #button-controls {
                flex-direction: column-reverse; /* Stack from bottom up */
                align-items: flex-end; /* Align to the right */
                gap: 10px; /* Adjust gap for mobile */
                top: auto;
                bottom: 20px;
                transform: translateY(0);
                right: 20px;
            }

            .zoom-button { /* Apply larger size for all zoom/fit/home buttons on mobile */
                width: 48px;
                height: 48px;
            }
            .zoom-button img { /* Apply larger icon size on mobile */
                width: 24px;
                height: 24px;
            }

            #zoomModeBtn {
                display: flex; /* Show zoomModeBtn on mobile */
                order: 1; /* Place zoomModeBtn above symbolsBtn */
            }
            #symbolsBtn {
                order: 2; /* Place symbolsBtn below zoomModeBtn */
            }

            #zoom-controls-expanded {
                position: absolute;
                bottom: calc(100% + 10px); /* Position above zoomModeBtn + gap */
                right: 0;
                transform-origin: bottom right; /* Transform from bottom right */
                opacity: 0;
                pointer-events: none;
                transform: translateY(20px); /* Animate upwards from zoomModeBtn */
                display: flex; /* Always display flex so that it can be transitioned */
                flex-direction: column; /* Stack buttons vertically */
                gap: 10px;
            }

            #zoom-controls-expanded.expanded {
                opacity: 1;
                pointer-events: auto;
                transform: translateY(0);
            }

            /* Adjust symbols-iframe-container width for mobile */
            #symbols-iframe-container {
                width: calc(100vw - 80px); /* Default width, will be overridden by JS */
                min-width: unset; /* Remove min-width constraint for mobile */
                max-width: unset; /* Remove max-width constraint for mobile */
                /* Add padding to the iframe to prevent content from being under the close button */
                padding-top: 56px; /* Space for the close button */
            }
            #symbols-iframe {
                height: calc(100% - 56px); /* Adjust iframe height to account for padding */
            }
        }

        /* Desktop-specific order for symbols button */
        @media (min-width: 769px) {
            #symbolsBtn {
                order: 99; /* Push to the very bottom */
            }
        }


        /* Стилі для фонового canvas завантаження */
        #loading-background-canvas {
            position: absolute; /* Відносно canvas-container */
            top: 0;
            left: 0;
            width: 100%; /* Заповнює батьківський контейнер */
            height: 100%; /* Заповнює батьківський контейнер */
            z-index: 50; /* Вище за background-canvas, нижче за grid-wrapper */
            filter: blur(10px); /* Розмиття */
            opacity: 1; /* Початково видимий */
            transition: opacity 0.5s ease-out; /* Плавне зникнення */
            background-color: #f0f4f8; /* Колір, якщо зображення не завантажилось */
        }

        #loading-background-canvas.hide-loading {
            opacity: 0;
            pointer-events: none; /* Вимикаємо взаємодію після приховування */
        }

        /* Стилі для спінера завантаження */
        #loading-spinner {
            z-index: 100; /* Вище за все під час завантаження */
            transition: opacity 0.5s ease-out; /* Плавне зникнення */
        }
        #loading-spinner.hidden {
            opacity: 0;
            pointer-events: none; /* Вимикаємо взаємодію після приховування */
        }

        /* Стилі для кругового спінера */
        .circular-spinner {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3b82f6; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite; /* Додано анімацію */
        }

        /* Анімація для спінера */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Стилі для кастомного випадаючого списку */
        #drawing-selector-container {
            position: absolute;
            top: 66px;
            left: 20px;
            z-index: 10;
            font-family: 'Montserrat', sans-serif;
        }

        .custom-select-display {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1rem;
            background-color: #f9f9f9; /* Плоский фон */
            cursor: pointer;
            outline: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Тінь */
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            min-width: 150px; /* Мінімальна ширина для видимості */
        }

        .custom-select-display:hover {
            background-color: #e0e0e0; /* Сірий при наведенні */
        }

        .custom-select-display .arrow {
            width: 8px; /* Зменшений розмір */
            height: 8px; /* Зменшений розмір */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292%22%20height%3D%22292%22%3E%3Cpath%20fill%3D%22%23737373%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.2c-6.8%200-13.3%202.8-17.7%208.4S.1%2082.5%204.5%2088l128%20127.9c3.9%203.9%209.7%206.2%2015.6%206.2%205.9%200%2011.7-2.3%2015.6-6.2l128-127.9c4.4-4.5%206.7-10.8%206.7-17.7z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: center;
            background-size: contain; /* Змінено на contain для кращого масштабування */
        }

        .custom-select-options {
            position: absolute;
            top: 100%; /* Розміщуємо під селектором */
            left: 0;
            background-color: #ffffff;
            border: 1px solid #ddd;
            border-radius: 8px; /* Закруглені кути */
            box-shadow: 0 4px 8px rgba(0,0,0,0.15); /* Більш виражена тінь для меню */
            max-height: 200px;
            overflow-y: auto;
            display: none; /* Приховано за замовчуванням */
            flex-direction: column;
            gap: 4px; /* Відстань між кнопками */
            padding: 8px;
            min-width: 100%; /* Мінімальна ширина як у батьківського селектора */
            max-width: 600px; /* Максимальна ширина */
            box-sizing: border-box; /* Враховуємо padding у ширині */
        }

        .custom-select-options.open {
            display: flex;
        }

        .custom-select-option {
            padding: 10px 12px;
            background-color: #f0f0f0; /* Фон кнопки */
            border: none;
            border-radius: 6px; /* Закруглені кути кнопок */
            text-align: left;
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-size: 0.95rem;
            color: #333;
            white-space: nowrap; /* Запобігаємо перенесенню тексту */
            overflow: hidden; /* Обрізаємо, якщо текст занадто довгий */
            text-overflow: ellipsis; /* Додаємо три крапки */
        }

        .custom-select-option:hover {
            background-color: #e0e0e0; /* Сірий при наведенні */
        }

        .custom-select-option.selected {
            background-color: #3b82f6; /* Синій фон для вибраного елемента */
            color: #ffffff; /* Білий текст для вибраного елемента */
            font-weight: 500;
        }

        /* Прихований нативний select */
        #drawing-selector {
            display: none;
        }

        /* Стилі для контейнера іфрейму умовних позначень */
        #symbols-iframe-container {
            position: fixed;
            right: 0;
            top: 56px; /* Відступ зверху 56px */
            height: calc(100vh - 56px); /* Висота з урахуванням верхнього відступу */
            width: 30vw; /* Ширина панелі, буде динамічно змінюватися */
            min-width: 280px; /* Мінімальна ширина для мобільних */
            max-width: 400px; /* Максимальна ширина для десктопів */
            background-color: #f9f9f9;
            box-shadow: -5px 0 15px rgba(0,0,0,0.2);
            z-index: 20;
            overflow: hidden; /* Приховуємо вміст, що виходить за межі контейнера */
            display: flex;
            flex-direction: column;
            transform: translateX(100%); /* Початково прихований, висувається збоку */
            transition: transform 0.3s ease-out; /* Анімація висування */
        }

        #symbols-iframe-container.open {
            transform: translateX(0); /* Висувається на екран */
        }

        #symbols-iframe {
            flex-grow: 1; /* Займає весь доступний простір */
            width: 100%;
            border: none;
        }

        /* Стилі для кнопки закриття на панелі */
        #panelCloseBtn {
            position: absolute;
            top: 10px; /* Відступ від верхнього краю */
            right: 20px; /* Змінено: відступ від правого краю на 20px */
            background: none;
            border: none;
            cursor: pointer;
            z-index: 21; /* Вище за іфрейм */
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background-color: rgba(224, 224, 224, 0.8); /* Напівпрозорий фон */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.2s ease;
        }

        #panelCloseBtn:hover {
            background-color: rgba(204, 204, 204, 0.9);
        }

        #panelCloseBtn img {
            width: 24px;
            height: 24px;
        }

        /* Стилі для активного стану кнопки "Умовні позначення" */
        #symbolsBtn.active {
            background-color: #3b82f6; /* Синій колір для активного стану */
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="loading-background-canvas"></canvas>
        <div id="loading-spinner" style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background-color: rgba(255, 255, 255, 0.75); z-index: 50; border-radius: 8px;">
            <div class="circular-spinner"></div>
        </div>
        <canvas id="background-canvas"></canvas>
        <canvas id="low-res-background-canvas"></canvas>
        <canvas id="mid-res-background-canvas"></canvas> <div id="grid-wrapper">
        </div>
    </div>

    <div id="button-controls">
        <button id="symbolsBtn" class="zoom-button" aria-label="Умовні позначення" title="Умовні позначення">
            <img src="https://img.icons8.com/material-sharp/48/737373/list.png" alt="Умовні позначення">
        </button>
        <button id="zoomModeBtn" class="zoom-button" aria-label="Розгорнути елементи керування масштабуванням" title="Розгорнути елементи керування масштабуванням">
            <img src="https://img.icons8.com/fluency-systems-regular/48/737373/zoom-mode.png" alt="Елементи керування масштабуванням">
        </button>
        <div id="zoom-controls-expanded">
            <button id="zoomInBtn" class="zoom-button" aria-label="Збільшити масштаб" title="Збільшити масштаб">
                <img src="https://img.icons8.com/android/48/737373/plus.png" alt="Збільшити масштаб">
            </button>
            <button id="zoomOutBtn" class="zoom-button" aria-label="Зменшити масштаб" title="Зменшити масштаб">
                <img src="https://img.icons8.com/material-sharp/48/737373/minus.png" alt="Зменшити масштаб">
            </button>
            <button id="homeBtn" class="zoom-button" aria-label="Повернути початкове положення" title="Повернути початкове положення">
                <img src="https://img.icons8.com/material-outlined/48/737373/collapse.png" alt="Повернути початкове положення">
            </button>
            <button id="fitButton" class="zoom-button" aria-label="Припасувати контент" title="Припасувати контент">
                <img src="https://img.icons8.com/material/48/737373/merge-horizontal--v1.png" alt="Припасувати контент">
            </button>
        </div>
    </div>

    <div id="drawing-selector-container">
        <div class="custom-select-display" tabindex="0">
            <span class="selected-value">Виберіть план</span>
            <div class="arrow"></div>
        </div>
        <div class="custom-select-options">
            </div>
        <select id="drawing-selector">
            </select>
    </div>

    <div id="symbols-iframe-container">
        <button id="panelCloseBtn" aria-label="Закрити">
            <img src="https://img.icons8.com/material-outlined/48/737373/delete-sign.png" alt="Закрити">
        </button>
        <iframe id="symbols-iframe" src=""></iframe> </div>

    <script>
        // Отримання посилань на елементи DOM
        const canvasContainer = document.getElementById('canvas-container');
        const gridWrapper = document.getElementById('grid-wrapper'); // Обгортка для сітки
        const backgroundCanvas = document.getElementById('background-canvas'); // Фоновий canvas для плиток
        const lowResBackgroundCanvas = document.getElementById('low-res-background-canvas'); // Канвас для низької роздільної здатності
        const midResBackgroundCanvas = document.getElementById('mid-res-background-canvas'); // Новий канвас для середньої роздільної здатності
        const loadingBackgroundCanvas = document.getElementById('loading-background-canvas'); // Фоновий canvas для завантаження
        const loadingSpinner = document.getElementById('loading-spinner'); // Спінер завантаження
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const homeBtn = document.getElementById('homeBtn'); // Кнопка "Додому"
        const fitButton = document.getElementById('fitButton'); // Змінено ID кнопки "Припасувати"
        const symbolsBtn = document.getElementById('symbolsBtn'); // Кнопка "Умовні позначення"
        const symbolsIframeContainer = document.getElementById('symbols-iframe-container'); // Контейнер іфрейму
        const panelCloseBtn = document.getElementById('panelCloseBtn'); // Додано: Кнопка закриття панелі
        const drawingSelector = document.getElementById('drawing-selector'); // Випадаючий список (прихований)
        const buttonControls = document.getElementById('button-controls'); // Додано: Посилання на контейнер кнопок
        const symbolsIframe = document.getElementById('symbols-iframe'); // Додано: Посилання на іфрейм умовних позначень
        const zoomModeBtn = document.getElementById('zoomModeBtn'); // Нова кнопка zoomMode
        const zoomControlsExpanded = document.getElementById('zoom-controls-expanded'); // Контейнер для розгорнутих кнопок зуму


        // Кастомні елементи селектора
        const customSelectDisplay = document.querySelector('.custom-select-display');
        const customSelectOptions = document.querySelector('.custom-select-options');
        const selectedValueSpan = document.querySelector('.selected-value');

        let imageUrl = 'https://wgis.project.co.ua/nadpilna/proj.jpg'; // URL зображення (буде оновлюватися)
        const configUrl = 'https://wgis.project.co.ua/nadpilna/config.json'; // URL файлу конфігурації

        const baseTileSize = 400; // Базовий розмір кожної плитки (в пікселях)
        let currentZoomLevel = 1.0; // Початковий рівень масштабування
        const fixedMinZoomLevel = 0.08; // Мінімальний рівень масштабування, щоб не зменшувати надто сильно
        const maxZoomLevel = 2.0; // Максимальний рівень масштабування до 200%
        const buttonZoomFactor = 1.5; // Змінено: Сильно збільшений коефіцієнт зуму для кнопок
        const mouseZoomFactor = 1.02; // Коефіцієнт зуму для коліщатка миші

        let tileData = []; // Масив для зберігання даних про кожну плитку
        let imgGlobal = null; // Зберігаємо зображення після завантаження, щоб не завантажувати його знову
        let observer = null; // Зберігаємо IntersectionObserver

        // Змінні для перетягування (панорамування)
        let isDragging = false;
        let startX, startY; // Початкові координати кліка/дотику
        let currentPanX = 0; // Поточна позиція translateX для gridWrapper
        let currentPanY = 0; // Поточна позиція translateY для gridWrapper
        let initialPanX = 0; // Початкова позиція translateX при початку перетягування
        let initialPanY = 0; // Початкова позиція translateY при початку перетягування
        let initialContentZoom = 0; // Зберігаємо початковий зум для кнопки "Додому"
        let initialContentPanX = 0; // Зберігаємо початковий panX для кнопки "Додому"
        let initialContentPanY = 0; // Зберігаємо початковий panY для кнопки "Додому"


        // Змінні для pinch-to-zoom
        let initialPinchDistance = 0;
        let initialZoomLevel = 1.0;
        let isPinching = false;

        // Флаг для відстеження анімації зуму
        let isZooming = false; // Нова змінна для відстеження анімації зуму

        // Поріг масштабування для перемикання між шарами
        const lowResThreshold = 0.25; // 25% zoom level
        const midResThreshold = 0.50; // 50% zoom level

        const lowResCanvasResolutionFactor = 0.25; // Коефіцієнт роздільної здатності для low-res canvas (25%)
        const midResCanvasResolutionFactor = 0.50; // Коефіцієнт роздільної здатності для mid-res canvas (50%)

        let resizeZoomTimeout = null; // Змінна для зберігання ID таймера для zoom to fit при зміні розміру вікна

        const MOBILE_BREAKPOINT_WIDTH = 768; // Define mobile breakpoint width
        const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0; // Check for touch interface

        // Function to determine if it's a mobile view
        function isMobileView() {
            return window.innerWidth <= MOBILE_BREAKPOINT_WIDTH && hasTouch;
        }

        // Функція для малювання плитки на canvas
        function drawTile(canvas, img, sx, sy, sWidth, sHeight) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Очищаємо перед малюванням
            ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
            canvas.classList.add('loaded'); // Додаємо клас для анімації проявлення
        }

        // Функція для малювання розмитого фонового зображення для плиток (прив'язаний до контенту)
        function drawBackgroundCanvas(img) {
            // Встановлюємо розміри фонового canvas відповідно до розмірів оригінального зображення
            backgroundCanvas.width = img.width;
            backgroundCanvas.height = img.height;

            const ctx = backgroundCanvas.getContext('2d');
            ctx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height); // Очищаємо canvas
            ctx.drawImage(img, 0, 0); // Малюємо оригінальне зображення на canvas
            // CSS filter: blur(5px) застосовується автоматично
        }

        // Функція для малювання розмитого фонового зображення для екрану завантаження (на весь екран)
        function drawLoadingBackground(img) {
            // Розміри канвасу завантаження відповідають розмірам контейнера
            loadingBackgroundCanvas.width = canvasContainer.clientWidth;
            loadingBackgroundCanvas.height = canvasContainer.clientHeight;

            const ctx = loadingBackgroundCanvas.getContext('2d');
            ctx.clearRect(0, 0, loadingBackgroundCanvas.width, loadingBackgroundCanvas.height);

            if (!img || img.naturalWidth === 0) {
                // Якщо зображення ще не завантажено або порожнє, малюємо просто фон
                ctx.fillStyle = '#f0f4f8';
                ctx.fillRect(0, 0, loadingBackgroundCanvas.width, loadingBackgroundCanvas.height);
                return;
            }

            const canvasWidth = loadingBackgroundCanvas.width;
            const canvasHeight = loadingBackgroundCanvas.height;
            const imgAspect = img.naturalWidth / img.naturalHeight;
            const canvasAspect = canvasWidth / canvasHeight;

            let drawWidth, drawHeight, offsetX, offsetY;

            // Calculate to cover the canvas (aspect-ratio-preserving)
            if (imgAspect > canvasAspect) {
                // Image is wider than canvas, fit by height and crop width
                drawHeight = canvasHeight;
                drawWidth = canvasHeight * imgAspect;
                offsetX = (canvasWidth - drawWidth) / 2;
                offsetY = 0;
            } else {
                // Image is taller than canvas, fit by width and crop height
                drawWidth = canvasWidth;
                drawHeight = canvasWidth / imgAspect;
                offsetY = (canvasHeight - drawHeight) / 2;
                offsetX = 0;
            }

            ctx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, offsetX, offsetY, drawWidth, drawHeight);
            // CSS filter blur is applied via CSS
        }

        // Функція для малювання фонового канвасу з низькою роздільною здатністю
        function drawLowResBackgroundCanvas(img) {
            const scaledWidth = img.width * lowResCanvasResolutionFactor;
            const scaledHeight = img.height * lowResCanvasResolutionFactor;

            lowResBackgroundCanvas.width = scaledWidth;
            lowResBackgroundCanvas.height = scaledHeight;

            const ctx = lowResBackgroundCanvas.getContext('2d');
            ctx.clearRect(0, 0, lowResBackgroundCanvas.width, lowResBackgroundCanvas.height);
            ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, scaledWidth, scaledHeight);
        }

        // Функція для малювання фонового канвасу з середньою роздільною здатністю
        function drawMidResBackgroundCanvas(img) {
            const scaledWidth = img.width * midResCanvasResolutionFactor;
            const scaledHeight = img.height * midResCanvasResolutionFactor;

            midResBackgroundCanvas.width = scaledWidth;
            midResBackgroundCanvas.height = scaledHeight;

            const ctx = midResBackgroundCanvas.getContext('2d');
            ctx.clearRect(0, 0, midResBackgroundCanvas.width, midResBackgroundCanvas.height);
            ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, scaledWidth, scaledHeight);
        }

        // Функція для завантаження та обробки зображення
        function processImage() {
            // Очищаємо обгортку сітки перед перемальовуванням
            gridWrapper.innerHTML = '';
            tileData = []; // Очищаємо дані про плитки

            // Відключаємо старий observer, якщо він існує
            if (observer) {
                observer.disconnect();
            }

            // Показуємо спінер завантаження
            loadingSpinner.classList.remove('hidden');

            // Малюємо початковий фон завантаження (пустий або з плейсхолдером)
            drawLoadingBackground(null); // Малюємо порожній фон завантаження

            const img = new Image();
            img.crossOrigin = 'Anonymous'; // Важливо для завантаження зображень з інших доменів

            img.onload = () => {
                imgGlobal = img; // Зберігаємо зображення для подальшого використання
                
                calculateInitialZoomAndPan(img); // Обчислюємо початковий зум та панорамування
                drawBackgroundCanvas(imgGlobal); // Малюємо розмитий фон для плиток (висока роздільна здатність)
                drawLowResBackgroundCanvas(imgGlobal); // Малюємо фон низької роздільної здатності
                drawMidResBackgroundCanvas(imgGlobal); // Малюємо фон середньої роздільної здатності
                drawLoadingBackground(imgGlobal); // Оновлюємо фон завантаження з зображенням

                // Приховуємо фоновий canvas завантаження та спінер
                loadingBackgroundCanvas.classList.add('hide-loading');
                loadingSpinner.classList.add('hidden');
                // Видимість основного контенту ( плиток/фону низької роздільної здатності) буде встановлена в applyTransform

                // Оновлюємо функціонал кнопки "Припасувати" залежно від орієнтації зображення
                updateFitButtonFunctionality();
                updateHomeButtonIcon(); // Оновлюємо іконку кнопки "Додому"
                updateHomeButtonState(); // Оновлюємо стан кнопки "Додому"
            };

            img.onerror = () => {
                console.error('Помилка завантаження зображення:', imageUrl);
                // Приховуємо фоновий canvas завантаження та спінер, якщо сталася помилка
                loadingBackgroundCanvas.classList.add('hide-loading');
                loadingSpinner.classList.add('hidden');
            };

            img.src = imageUrl; // Встановлення джерела зображення
        }

        // Функція для обчислення початкового зуму та панорамування
        function calculateInitialZoomAndPan(img) {
            const imgWidth = img.width;
            const imgHeight = img.height;

            // Розрахунок кількості плиток по ширині та висоті
            const cols = Math.ceil(imgWidth / baseTileSize);
            const rows = Math.ceil(imgHeight / baseTileSize);

            // Визначення розмірів всього блоку плиток без масштабування
            const totalGridWidth = cols * baseTileSize;
            const totalGridHeight = rows * baseTileSize;

            // Отримання видимих розмірів контейнера (з урахуванням padding)
            const viewportWidth = canvasContainer.clientWidth;
            const viewportHeight = canvasContainer.clientHeight;

            // Розрахунок масштабу, щоб зображення вписалося в контейнер
            let fitScaleX = viewportWidth / totalGridWidth;
            let fitScaleY = viewportHeight / totalGridHeight;
            let calculatedMinZoom = Math.min(fitScaleX, fitScaleY);

            // Встановлюємо currentZoomLevel. Він буде або розрахованим мінімальним,
            // або fixedMinZoomLevel, або maxZoomLevel, якщо розрахований занадто великий.
            currentZoomLevel = Math.max(fixedMinZoomLevel, calculatedMinZoom);
            currentZoomLevel = Math.min(currentZoomLevel, maxZoomLevel);

            // Обчислюємо початкові координати для центрування
            currentPanX = (viewportWidth - totalGridWidth * currentZoomLevel) / 2;
            currentPanY = (viewportHeight - totalGridHeight * currentZoomLevel) / 2;

            // Зберігаємо початкові значення для кнопки "Додому"
            initialContentZoom = currentZoomLevel;
            initialContentPanX = currentPanX;
            initialContentPanY = currentPanY;

            renderTiles(img); // Рендеримо плитки з новим масштабом
            applyTransform(currentZoomLevel, currentPanX, currentPanY); // Застосовуємо зум та панорамування, що також керує видимістю
            updateZoomButtonStates(); // Оновлюємо стан кнопок зуму
        }


        // Функція для рендерингу плиток
        function renderTiles(img) {
            const imgWidth = img.width;
            const imgHeight = img.height;

            // Розрахунок кількості плиток по ширині та висоті
            const cols = Math.ceil(imgWidth / baseTileSize);
            const rows = Math.ceil(imgHeight / baseTileSize);

            // Відключаємо старий observer перед очищенням DOM
            if (observer) {
                observer.disconnect();
            }

            // Очищаємо обгортку сітки перед перемальовуванням
            gridWrapper.innerHTML = '';
            tileData = []; // Очищаємо дані про плитки

            // Встановлення розмірів обгортки сітки
            gridWrapper.style.gridTemplateColumns = `repeat(${cols}, ${baseTileSize}px)`;
            gridWrapper.style.gridTemplateRows = `repeat(${rows}, ${baseTileSize}px)`;

            // Встановлення розмірів gridWrapper, щоб він мав правильні розміри для масштабування
            gridWrapper.style.width = `${cols * baseTileSize}px`;
            gridWrapper.style.height = `${rows * baseTileSize}px`;

            // Створення Intersection Observer для лінивого завантаження
            observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Плитка увійшла у видиму область
                        const canvas = entry.target;
                        const index = parseInt(canvas.dataset.index);
                        const data = tileData[index];
                        if (data && !canvas.classList.contains('loaded')) {
                            canvas.width = baseTileSize; // Встановлюємо актуальний розмір плитки
                            canvas.height = baseTileSize; // Встановлюємо актуальний розмір плитки
                            drawTile(canvas, img, data.sx, data.sy, data.sWidth, data.sHeight);
                        }
                    } else {
                        // Плитка вийшла з видимої області, скидаємо її стан, щоб вона знову проявилася при поверненні
                        const canvas = entry.target;
                        canvas.classList.remove('loaded');
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height); // Очищаємо canvas
                    }
                });
            }, {
                root: canvasContainer, // Контейнер, який є видимим вікном
                rootMargin: '0px', // Відступ навколо кореневого елемента
                threshold: 0 // Спрацьовує, коли 0% елемента видно (тобто, як тільки з'являється)
            });

            // Створення та додавання canvas для кожної плитки
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = baseTileSize; // Встановлюємо актуальний розмір плитки
                    canvas.height = baseTileSize; // Встановлюємо актуальний розмір плитки
                    canvas.dataset.index = tileData.length; // Зберігаємо індекс для доступу до даних

                    // Обчислення координат для вирізання частини зображення
                    const sx = c * baseTileSize;
                    const sy = r * baseTileSize;
                    const sWidth = Math.min(baseTileSize, imgWidth - sx);
                    const sHeight = Math.min(baseTileSize, imgHeight - sy);

                    // Зберігаємо дані для малювання
                    tileData.push({ sx, sy, sWidth, sHeight });

                    gridWrapper.appendChild(canvas); // Додаємо canvas до обгортки сітки
                    observer.observe(canvas); // Починаємо спостерігати за новою плиткою
                }
            }
        }

        // Функція для оновлення відображення масштабу (тепер виводить в консоль)
        function updateZoomDisplay() {
            console.log(`Масштаб: ${Math.round(currentZoomLevel * 100)}%`);
            console.log(`Позиція (X, Y): (${currentPanX.toFixed(2)}px, ${currentPanY.toFixed(2)}px)`);
        }

        // Функція для застосування transform (scale та translate) до gridWrapper, backgroundCanvas та lowResBackgroundCanvas
        function applyTransform(zoom, panX, panY) {
            const transformStringGrid = `translate(${panX}px, ${panY}px) scale(${zoom})`;

            // Завжди оновлюємо трансформацію для всіх шарів, незалежно від їх видимості
            const lowResScale = zoom / lowResCanvasResolutionFactor;
            lowResBackgroundCanvas.style.transform = `translate(${panX}px, ${panY}px) scale(${lowResScale})`;

            const midResScale = zoom / midResCanvasResolutionFactor;
            midResBackgroundCanvas.style.transform = `translate(${panX}px, ${panY}px) scale(${midResScale})`;

            gridWrapper.style.transform = transformStringGrid;
            backgroundCanvas.style.transform = transformStringGrid;


            if (zoom < lowResThreshold) {
                // Показуємо фон низької роздільної здатності
                lowResBackgroundCanvas.style.opacity = 1;
                lowResBackgroundCanvas.style.pointerEvents = 'auto';

                midResBackgroundCanvas.style.opacity = 0; // Приховуємо середню роздільну здатність
                midResBackgroundCanvas.style.pointerEvents = 'none';

                backgroundCanvas.style.opacity = 0; // Приховуємо високу роздільну здатність
                backgroundCanvas.style.pointerEvents = 'none';

                gridWrapper.style.opacity = 0; // Приховуємо плитки
                gridWrapper.style.pointerEvents = 'none';
            } else if (zoom >= lowResThreshold && zoom < midResThreshold) {
                // Показуємо фон середньої роздільної здатності
                lowResBackgroundCanvas.style.opacity = 0; // Приховуємо низьку роздільну здатність
                lowResBackgroundCanvas.style.pointerEvents = 'none';

                midResBackgroundCanvas.style.opacity = 1;
                midResBackgroundCanvas.style.pointerEvents = 'auto';

                backgroundCanvas.style.opacity = 0; // Приховуємо високу роздільну здатність
                backgroundCanvas.style.pointerEvents = 'none';

                gridWrapper.style.opacity = 0; // Приховуємо плитки
                gridWrapper.style.pointerEvents = 'none';
            } else { // zoom >= midResThreshold
                // Показуємо плитки та фон високої роздільної здатності
                lowResBackgroundCanvas.style.opacity = 0; // Приховуємо низьку роздільну здатність
                lowResBackgroundCanvas.style.pointerEvents = 'none';

                midResBackgroundCanvas.style.opacity = 0; // Приховуємо середню роздільну здатність
                midResBackgroundCanvas.style.pointerEvents = 'none';

                backgroundCanvas.style.opacity = 1;
                backgroundCanvas.style.pointerEvents = 'none';

                gridWrapper.style.opacity = 1;
                gridWrapper.style.pointerEvents = 'auto';
            }
            updateZoomDisplay();
        }

        // Функція для застосування зуму та коригування панорамування
        function handleZoom(newZoom, zoomCenterX = null, zoomCenterY = null) {
            const oldZoom = currentZoomLevel;
            currentZoomLevel = Math.max(fixedMinZoomLevel, Math.min(maxZoomLevel, newZoom));

            if (oldZoom === currentZoomLevel) {
                return;
            }

            // Встановлюємо isZooming на true, коли починається операція масштабування
            isZooming = true;

            const viewportRect = canvasContainer.getBoundingClientRect();
            const viewportWidth = viewportRect.width;
            const viewportHeight = viewportRect.height;

            let contentCenterX, contentCenterY;

            if (zoomCenterX !== null && zoomCenterY !== null) {
                // Це зум мишкою або pinch-to-zoom
                // Пришвидшуємо анімацію для цього кроку
                gridWrapper.style.transition = 'transform 0.05s ease-out, opacity 0.05s ease-in-out';
                backgroundCanvas.style.transition = 'transform 0.05s ease-out, opacity 0.05s ease-in-out';
                lowResBackgroundCanvas.style.transition = 'transform 0.05s ease-out, opacity 0.05s ease-in-out';
                midResBackgroundCanvas.style.transition = 'transform 0.05s ease-out, opacity 0.05s ease-in-out';

                // Перетворюємо координати області перегляду в координати вмісту до нового масштабу
                contentCenterX = (zoomCenterX - currentPanX) / oldZoom;
                contentCenterY = (zoomCenterY - currentPanY) / oldZoom;
            } else {
                // Це зум кнопками або інший тип, повертаємо стандартну анімацію
                gridWrapper.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
                backgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
                lowResBackgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
                midResBackgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';

                // Масштабування навколо центру області перегляду (для кнопок)
                contentCenterX = (viewportWidth / 2 - currentPanX) / oldZoom;
                contentCenterY = (viewportHeight / 2 - currentPanY) / oldZoom;
            }

            // Обчислюємо нове панорамування на основі центру вмісту та нового рівня масштабу
            currentPanX = (zoomCenterX !== null ? zoomCenterX : viewportWidth / 2) - (contentCenterX * currentZoomLevel);
            currentPanY = (zoomCenterY !== null ? zoomCenterY : viewportHeight / 2) - (contentCenterY * currentZoomLevel);

            applyTransform(currentZoomLevel, currentPanX, currentPanY);

            // Перемальовуємо видимі плитки, якщо вони мають бути видимими
            if (observer && imgGlobal && currentZoomLevel >= midResThreshold) { // Змінено поріг для перемальовування плиток
                gridWrapper.querySelectorAll('canvas').forEach(canvas => {
                    const index = parseInt(canvas.dataset.index);
                    const data = tileData[index];
                    const rect = canvas.getBoundingClientRect();
                    const containerRect = canvasContainer.getBoundingClientRect();
                    if (rect.top < containerRect.bottom && rect.bottom > containerRect.top &&
                        rect.left < containerRect.right && rect.right > containerRect.left) {
                        drawTile(canvas, imgGlobal, data.sx, data.sy, data.sWidth, data.sHeight);
                    }
                });
            }
            updateZoomButtonStates(); // Оновлюємо стан кнопок зуму
            updateFitButtonFunctionality(); // Оновлюємо функціонал кнопки "Припасувати"
            updateHomeButtonIcon(); // Оновлюємо іконку кнопки "Додому"
            updateHomeButtonState(); // Оновлюємо стан кнопки "Додому"
        }

        // Функція для оновлення стану кнопок зуму
        function updateZoomButtonStates() {
            if (currentZoomLevel <= fixedMinZoomLevel) {
                zoomOutBtn.classList.add('disabled');
                zoomOutBtn.disabled = true;
            } else {
                zoomOutBtn.classList.remove('disabled');
                zoomOutBtn.disabled = false;
            }

            if (currentZoomLevel >= maxZoomLevel) {
                zoomInBtn.classList.add('disabled');
                zoomInBtn.disabled = true;
            } else {
                zoomInBtn.classList.remove('disabled');
                zoomInBtn.disabled = false;
            }
        }

        // Функція для повернення до початкового положення та розміру (zoom to fit)
        function resetView() {
            if (imgGlobal) {
                console.log('Кнопка "Додому" натиснута. Виконання "zoom to fit"...');
                // Перед скиданням, переконаємося, що перехід повернуто до стандартного
                gridWrapper.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
                backgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
                lowResBackgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
                midResBackgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
                calculateInitialZoomAndPan(imgGlobal); // Ця функція вже виконує "zoom to fit" і викликає applyTransform
                updateHomeButtonIcon(); // Оновлюємо іконку кнопки "Додому" після скидання
                updateFitButtonFunctionality(); // Оновлюємо іконку кнопки "Припасувати" після скидання
                updateHomeButtonState(); // Оновлюємо стан кнопки "Додому"
            }
        }

        // Функція для припасування контенту по висоті
        function fitContentToHeight() {
            if (!imgGlobal) return;

            const oldZoom = currentZoomLevel; // Зберігаємо старий зум для розрахунків
            const imgWidth = imgGlobal.width;
            const imgHeight = imgGlobal.height;
            const cols = Math.ceil(imgWidth / baseTileSize);
            const rows = Math.ceil(imgHeight / baseTileSize);
            const totalGridWidth = cols * baseTileSize;
            const totalGridHeight = rows * baseTileSize;
            const viewportWidth = canvasContainer.clientWidth;
            const viewportHeight = canvasContainer.clientHeight;

            // Calculate new zoom to fit height
            let newZoom = viewportHeight / totalGridHeight;
            newZoom = Math.max(fixedMinZoomLevel, Math.min(maxZoomLevel, newZoom));

            // Calculate panY to center vertically (full content height)
            let newPanY = (viewportHeight - totalGridHeight * newZoom) / 2;

            // Calculate panX to maintain current visible horizontal center, then clamp
            const screenCenterX = viewportWidth / 2;
            const contentCenterX = (screenCenterX - currentPanX) / oldZoom; // Current visible center in content coords
            let newPanX = screenCenterX - (contentCenterX * newZoom); // New pan to keep that center

            // Clamp newPanX
            const minPanX = viewportWidth - (totalGridWidth * newZoom);
            const maxPanX = 0;
            if (totalGridWidth * newZoom < viewportWidth) { // If content is smaller than viewport horizontally, center it
                newPanX = (viewportWidth - totalGridWidth * newZoom) / 2;
            } else {
                newPanX = Math.max(minPanX, Math.min(maxPanX, newPanX));
            }

            currentZoomLevel = newZoom;
            currentPanX = newPanX;
            currentPanY = newPanY;

            gridWrapper.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            backgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            lowResBackgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            midResBackgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';

            applyTransform(currentZoomLevel, currentPanX, currentPanY);
            renderTiles(imgGlobal);
            updateZoomButtonStates(); // Оновлюємо стан кнопок зуму
            updateFitButtonFunctionality(); // Оновлюємо іконку кнопки "Припасувати"
            updateHomeButtonIcon(); // Оновлюємо іконку кнопки "Додому"
            updateHomeButtonState(); // Оновлюємо стан кнопки "Додому"
            console.log('Контент припасовано по висоті (з збереженням горизонтального центру).');
        }

        // Функція для припасування контенту по ширині
        function fitContentToWidth() {
            if (!imgGlobal) return;

            const oldZoom = currentZoomLevel; // Зберігаємо старий зум для розрахунків
            const imgWidth = imgGlobal.width;
            const imgHeight = imgGlobal.height;
            const cols = Math.ceil(imgWidth / baseTileSize);
            const rows = Math.ceil(imgHeight / baseTileSize);
            const totalGridWidth = cols * baseTileSize;
            const totalGridHeight = rows * baseTileSize;
            const viewportWidth = canvasContainer.clientWidth;
            const viewportHeight = canvasContainer.clientHeight;

            // Calculate new zoom to fit width
            let newZoom = viewportWidth / totalGridWidth;
            newZoom = Math.max(fixedMinZoomLevel, Math.min(maxZoomLevel, newZoom));

            // Calculate panX to center horizontally (full content width)
            let newPanX = (viewportWidth - totalGridWidth * newZoom) / 2;

            // Calculate panY to maintain current visible vertical center, then clamp
            const screenCenterY = viewportHeight / 2;
            const contentCenterY = (screenCenterY - currentPanY) / oldZoom; // Current visible center in content coords
            let newPanY = screenCenterY - (contentCenterY * newZoom); // New pan to keep that center

            // Clamp newPanY
            const minPanY = viewportHeight - (totalGridHeight * newZoom);
            const maxPanY = 0;
            if (totalGridHeight * newZoom < viewportHeight) { // If content is smaller than viewport vertically, center it
                newPanY = (viewportHeight - totalGridHeight * newZoom) / 2;
            } else {
                newPanY = Math.max(minPanY, Math.min(maxPanY, newPanY));
            }

            currentZoomLevel = newZoom;
            currentPanX = newPanX;
            currentPanY = newPanY;

            gridWrapper.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            backgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            lowResBackgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            midResBackgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';

            applyTransform(currentZoomLevel, currentPanX, currentPanY);
            renderTiles(imgGlobal);
            updateZoomButtonStates(); // Оновлюємо стан кнопок зуму
            updateFitButtonFunctionality(); // Оновлюємо іконку кнопки "Припасувати"
            updateHomeButtonIcon(); // Оновлюємо іконку кнопки "Додому"
            updateHomeButtonState(); // Оновлюємо стан кнопки "Додому"
            console.log('Контент припасовано по ширині (з збереженням вертикального центру).');
        }

        // Функція для оновлення функціоналу кнопки "Припасувати" та її іконки
        function updateFitButtonFunctionality() {
            if (!imgGlobal) return;

            const fitButtonImg = fitButton.querySelector('img');
            const imgWidth = imgGlobal.width;
            const imgHeight = imgGlobal.height;

            const cols = Math.ceil(imgWidth / baseTileSize);
            const rows = Math.ceil(imgHeight / baseTileSize);

            const totalGridWidth = cols * baseTileSize;
            const totalGridHeight = rows * baseTileSize;

            const viewportWidth = canvasContainer.clientWidth;
            const viewportHeight = canvasContainer.clientHeight;

            const currentContentWidth = totalGridWidth * currentZoomLevel;
            const currentContentHeight = totalGridHeight * currentZoomLevel;

            // Визначаємо, чи вміст більший за контейнер з деяким допуском
            const isContentTallerThanViewport = currentContentHeight > viewportHeight + 5; // +5px buffer
            const isContentWiderThanViewport = currentContentWidth > viewportWidth + 5; // +5px buffer

            // Визначаємо, чи вміст ідеально припасований до вікна перегляду
            const isPerfectlyFitWidth = Math.abs(currentContentWidth - viewportWidth) < 5 && Math.abs(currentPanX - (viewportWidth - currentContentWidth) / 2) < 5;
            const isPerfectlyFitHeight = Math.abs(currentContentHeight - viewportHeight) < 5 && Math.abs(currentPanY - (viewportHeight - currentContentHeight) / 2) < 5;


            if (imgHeight > imgWidth) { // Портретна орієнтація: за замовчуванням припасувати по ширині
                fitButton.onclick = fitContentToWidth;
                if (isContentTallerThanViewport) { // Якщо контент вищий за viewport, пропонуємо розгорнути по висоті
                    fitButtonImg.src = 'https://img.icons8.com/material-sharp/48/737373/merge-vertical.png';
                    fitButton.setAttribute('aria-label', 'Розгорнути по висоті');
                    fitButtonImg.alt = 'Розгорнути по висоті';
                    fitButton.title = 'Розгорнути по висоті';
                } else { // За замовчуванням merge-vertical для портрета, якщо не вищий
                    fitButtonImg.src = 'https://img.icons8.com/material-outlined/48/737373/split-horizontal.png';
                    fitButton.setAttribute('aria-label', 'Припасувати по ширині');
                    fitButtonImg.alt = 'Припасувати по ширині';
                    fitButton.title = 'Припасувати по ширині';
                }
                // Деактивуємо кнопку, якщо вже ідеально припасовано по ширині
                if (isPerfectlyFitWidth && Math.abs(currentZoomLevel * totalGridHeight - viewportHeight) < 5) {
                     fitButton.classList.add('disabled');
                     fitButton.disabled = true;
                } else {
                     fitButton.classList.remove('disabled');
                     fitButton.disabled = false;
                }

            } else { // Альбомна або квадратна орієнтація: за замовчуванням припасувати по висоті
                fitButton.onclick = fitContentToHeight;
                if (isContentWiderThanViewport) { // Якщо контент ширший за viewport, пропонуємо розгорнути по ширині
                    fitButtonImg.src = 'https://img.icons8.com/material/48/737373/merge-horizontal--v1.png';
                    fitButton.setAttribute('aria-label', 'Розгорнути по ширині');
                    fitButtonImg.alt = 'Розгорнути по ширині';
                    fitButton.title = 'Розгорнути по ширині';
                } else { // За замовчуванням merge-horizontal для альбомної/квадратної, якщо не ширший
                    fitButtonImg.src = 'https://img.icons8.com/material-two-tone/48/737373/split-vertical.png';
                    fitButton.setAttribute('aria-label', 'Припасувати по висоті');
                    fitButtonImg.alt = 'Припасувати по висоті';
                    fitButton.title = 'Припасувати по висоті';
                }
                // Деактивуємо кнопку, якщо вже ідеально припасовано по висоті
                if (isPerfectlyFitHeight && Math.abs(currentZoomLevel * totalGridWidth - viewportWidth) < 5) {
                     fitButton.classList.add('disabled');
                     fitButton.disabled = true;
                } else {
                     fitButton.classList.remove('disabled');
                     fitButton.disabled = false;
                }
            }
        }

        // Функція для оновлення іконки кнопки "Додому"
        function updateHomeButtonIcon() {
            if (!imgGlobal) return;

            const homeButtonImg = homeBtn.querySelector('img');
            const imgWidth = imgGlobal.width;
            const imgHeight = imgGlobal.height;

            const cols = Math.ceil(imgWidth / baseTileSize);
            const rows = Math.ceil(imgHeight / baseTileSize);

            const totalGridWidth = cols * baseTileSize;
            const totalGridHeight = rows * baseTileSize;

            const viewportWidth = canvasContainer.clientWidth;
            const viewportHeight = canvasContainer.clientHeight;

            const currentContentWidth = totalGridWidth * currentZoomLevel;
            const currentContentHeight = totalGridHeight * currentZoomLevel;

            // Перевіряємо, чи вміст менший за контейнер з деяким допуском
            const isContentSmallerThanViewport = currentContentWidth < viewportWidth - 5 && currentContentHeight < viewportHeight - 5; // -5px допуск

            if (isContentSmallerThanViewport) {
                homeButtonImg.src = 'https://img.icons8.com/material/48/737373/expand--v1.png';
                homeBtn.setAttribute('aria-label', 'Розгорнути до початкового розміру');
                homeButtonImg.alt = 'Розгорнути до початкового розміру';
                homeBtn.title = 'Розгорнути до початкового розміру';
            } else {
                homeButtonImg.src = 'https://img.icons8.com/material-outlined/48/737373/collapse.png';
                homeBtn.setAttribute('aria-label', 'Повернути початкове положення');
                homeButtonImg.alt = 'Повернути початкове положення';
                homeBtn.title = 'Повернути початкове положення';
            }
        }

        // Функція для оновлення стану кнопки "Додому"
        function updateHomeButtonState() {
            const tolerance = 0.01; // Допуск для порівняння чисел з плаваючою комою
            const panTolerance = 5; // Допуск для порівняння координат панорамування

            const isZoomLevelInitial = Math.abs(currentZoomLevel - initialContentZoom) < tolerance;
            const isPanXInitial = Math.abs(currentPanX - initialContentPanX) < panTolerance;
            const isPanYInitial = Math.abs(currentPanY - initialContentPanY) < panTolerance;

            if (isZoomLevelInitial && isPanXInitial && isPanYInitial) {
                homeBtn.classList.add('disabled');
                homeBtn.disabled = true;
            } else {
                homeBtn.classList.remove('disabled');
                homeBtn.disabled = false;
            }
        }


        // Обробники подій для збільшення зуму (повернуто до кліку)
        zoomInBtn.addEventListener('click', () => {
            if (zoomInBtn.disabled) return; // Запобігаємо дії, якщо кнопка неактивна
            handleZoom(currentZoomLevel * buttonZoomFactor); // Змінено на динамічний крок
        });

        // Обробники подій для зменшення зуму (повернуто до кліку)
        zoomOutBtn.addEventListener('click', () => {
            if (zoomOutBtn.disabled) return; // Запобігаємо дії, якщо кнопка неактивна
            handleZoom(currentZoomLevel / buttonZoomFactor); // Змінено на динамічний крок
        });

        // Додаємо обробник подій для кнопки "Додому"
        homeBtn.addEventListener('click', resetView);

        // Обробник подій для зуму коліщатком миші
        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault(); // Запобігаємо прокручуванню сторінки

            if (isDragging) return; // Заборонити зум мишкою під час перетягування

            const delta = Math.sign(e.deltaY); // -1 для збільшення, 1 для зменшення
            let newZoom;

            if (delta === -1) { // Збільшення
                newZoom = currentZoomLevel * mouseZoomFactor;
            } else { // Зменшення
                newZoom = currentZoomLevel / mouseZoomFactor;
            }

            // Отримуємо позицію миші відносно canvasContainer
            const rect = canvasContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            handleZoom(newZoom, mouseX, mouseY);
        });

        // Додаємо обробники transitionend для скидання isZooming
        gridWrapper.addEventListener('transitionend', (e) => {
            if (e.propertyName === 'transform') {
                isZooming = false;
                // Після завершення анімації, повертаємо стандартний перехід
                gridWrapper.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            }
            if (e.propertyName === 'opacity') {
                // Також повертаємо стандартний перехід для opacity, якщо він був змінений
                gridWrapper.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            }
        });
        backgroundCanvas.addEventListener('transitionend', (e) => {
            if (e.propertyName === 'transform') {
                isZooming = false;
                backgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            }
            if (e.propertyName === 'opacity') {
                backgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            }
        });
        lowResBackgroundCanvas.addEventListener('transitionend', (e) => {
            if (e.propertyName === 'transform') {
                isZooming = false;
                lowResBackgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            }
            if (e.propertyName === 'opacity') {
                lowResBackgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            }
        });
        midResBackgroundCanvas.addEventListener('transitionend', (e) => {
            if (e.propertyName === 'transform') {
                isZooming = false;
                midResBackgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            }
            if (e.propertyName === 'opacity') {
                midResBackgroundCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.5s ease-in-out';
            }
        });


        // Обробники подій для перетягування
        canvasContainer.addEventListener('mousedown', (e) => {
            // isZooming check removed to allow dragging during zoom animation
            isDragging = true;
            canvasContainer.classList.add('dragging');
            // Додаємо клас, який вимикає переходи
            gridWrapper.classList.add('no-transition');
            backgroundCanvas.classList.add('no-transition');
            lowResBackgroundCanvas.classList.add('no-transition');
            midResBackgroundCanvas.classList.add('no-transition');

            startX = e.clientX;
            startY = e.clientY;
            initialPanX = currentPanX; // Зберігаємо поточну позицію gridWrapper
            initialPanY = currentPanY;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;

            currentPanX = initialPanX + dx;
            currentPanY = initialPanY + dy;
            applyTransform(currentZoomLevel, currentPanX, currentPanY); // Застосовуємо transform
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            canvasContainer.classList.remove('dragging');
            // Видаляємо клас, який вимикав переходи
            gridWrapper.classList.remove('no-transition');
            backgroundCanvas.classList.remove('no-transition');
            lowResBackgroundCanvas.classList.remove('no-transition');
            midResBackgroundCanvas.classList.remove('no-transition');
            // Після завершення перетягування, перемальовуємо видимі плитки
            if (observer && imgGlobal && currentZoomLevel >= midResThreshold) {
                gridWrapper.querySelectorAll('canvas').forEach(canvas => {
                    const index = parseInt(canvas.dataset.index);
                    const data = tileData[index];
                    const rect = canvas.getBoundingClientRect();
                    const containerRect = canvasContainer.getBoundingClientRect();
                    if (rect.top < containerRect.bottom && rect.bottom > containerRect.top &&
                        rect.left < containerRect.right && rect.right > containerRect.left) {
                        drawTile(canvas, imgGlobal, data.sx, data.sy, data.sWidth, data.sHeight);
                    }
                });
            }
        });

        // Обробники подій для тач-скрінів (мобільні пристрої)
        canvasContainer.addEventListener('touchstart', (e) => {
            // isZooming check removed to allow dragging during zoom animation
            if (e.touches.length === 2) {
                isDragging = false; // Вимикаємо перетягування одним пальцем, якщо починається pinch-to-zoom
                isPinching = true;
                e.preventDefault(); // Запобігаємо стандартній поведінці браузера

                // Додаємо клас, який вимикає переходи
                gridWrapper.classList.add('no-transition');
                backgroundCanvas.classList.add('no-transition');
                lowResBackgroundCanvas.classList.add('no-transition');
                midResBackgroundCanvas.classList.add('no-transition');

                const touch1 = e.touches[0];
                const touch2 = e.touches[1];

                initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                
                // Зберігаємо початковий пан і зум для розрахунків pinch
                initialPanX = currentPanX;
                initialPanY = currentPanY;
                initialZoomLevel = currentZoomLevel;

            } else if (e.touches.length === 1) {
                isDragging = true;
                canvasContainer.classList.add('dragging');
                // Додаємо клас, який вимикає переходи
                gridWrapper.classList.add('no-transition');
                backgroundCanvas.classList.add('no-transition');
                lowResBackgroundCanvas.classList.add('no-transition');
                midResBackgroundCanvas.classList.add('no-transition');

                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                initialPanX = currentPanX;
                initialPanY = currentPanY;
            }
        }, { passive: false });

        canvasContainer.addEventListener('touchmove', (e) => {
            if (isPinching && e.touches.length === 2) {
                e.preventDefault(); // Запобігаємо стандартній поведінці браузера

                const touch1 = e.touches[0];
                const touch2 = e.touches[1];

                const currentPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                const scaleFactor = currentPinchDistance / initialPinchDistance;

                let newZoom = initialZoomLevel * scaleFactor;
                newZoom = Math.max(fixedMinZoomLevel, Math.min(maxZoomLevel, newZoom));

                // Обчислюємо поточний центр pinch-жесту відносно області перегляду
                const currentPinchMidpointX = (touch1.clientX + touch2.clientX) / 2;
                const currentPinchMidpointY = (touch1.clientY + touch2.clientY) / 2;

                // Отримуємо позицію canvasContainer
                const rect = canvasContainer.getBoundingClientRect();
                const zoomCenterX = currentPinchMidpointX - rect.left;
                const zoomCenterY = currentPinchMidpointY - rect.top;

                // Коригуємо панорамування, щоб центр pinch-жесту залишався в тому ж відносному положенні
                const oldContentX = (zoomCenterX - initialPanX) / initialZoomLevel;
                const oldContentY = (zoomCenterY - initialPanY) / initialZoomLevel;

                currentPanX = zoomCenterX - (oldContentX * newZoom);
                currentPanY = zoomCenterY - (oldContentY * newZoom);
                currentZoomLevel = newZoom; // Оновлюємо currentZoomLevel для наступної ітерації

                applyTransform(currentZoomLevel, currentPanX, currentPanY);

                // Перемальовуємо видимі плитки
                if (observer && imgGlobal && currentZoomLevel >= midResThreshold) {
                    gridWrapper.querySelectorAll('canvas').forEach(canvas => {
                        const index = parseInt(canvas.dataset.index);
                        const data = tileData[index];
                        const rect = canvas.getBoundingClientRect();
                        const containerRect = canvasContainer.getBoundingClientRect();
                        if (rect.top < containerRect.bottom && rect.bottom > containerRect.top &&
                            rect.left < containerRect.right && rect.right > containerRect.left) {
                            drawTile(canvas, imgGlobal, data.sx, data.sy, data.sWidth, data.sHeight);
                        }
                    });
                }
                updateZoomButtonStates(); // Оновлюємо стан кнопок зуму
                updateFitButtonFunctionality(); // Оновлюємо функціонал кнопки "Припасувати"
                updateHomeButtonIcon(); // Оновлюємо іконку кнопки "Додому"
                updateHomeButtonState(); // Оновлюємо стан кнопки "Додому"
            } else if (isDragging && e.touches.length === 1) {
                e.preventDefault();
                
                const dx = e.touches[0].clientX - startX;
                const dy = e.touches[0].clientY - startY;

                currentPanX = initialPanX + dx;
                currentPanY = initialPanY + dy;
                applyTransform(currentZoomLevel, currentPanX, currentPanY); // Застосовуємо transform
            }
        }, { passive: false });

        canvasContainer.addEventListener('touchend', () => {
            isDragging = false;
            isPinching = false;
            canvasContainer.classList.remove('dragging');
            // Видаляємо клас, який вимикав переходи
            gridWrapper.classList.remove('no-transition');
            backgroundCanvas.classList.remove('no-transition');
            lowResBackgroundCanvas.classList.remove('no-transition');
            midResBackgroundCanvas.classList.remove('no-transition');
            // Після завершення перетягування, перемальовуємо видимі плитки
            if (observer && imgGlobal && currentZoomLevel >= midResThreshold) {
                gridWrapper.querySelectorAll('canvas').forEach(canvas => {
                    const index = parseInt(canvas.dataset.index);
                    const data = tileData[index];
                    const rect = canvas.getBoundingClientRect();
                    const containerRect = canvasContainer.getBoundingClientRect();
                    if (rect.top < containerRect.bottom && rect.bottom > containerRect.top &&
                        rect.left < containerRect.right && rect.right > containerRect.left) {
                        drawTile(canvas, imgGlobal, data.sx, data.sy, data.sWidth, data.sHeight);
                    }
                });
            }
            updateZoomButtonStates(); // Оновлюємо стан кнопок зуму
            updateFitButtonFunctionality(); // Оновлюємо функціонал кнопки "Припасувати"
            updateHomeButtonIcon(); // Оновлюємо іконку кнопки "Додому"
            updateHomeButtonState(); // Оновлюємо стан кнопки "Додому"
        });

        // New function to handle map content repositioning to keep *current visible center*
        function recenterMapContent() {
            if (!imgGlobal) return;

            console.log("recenterMapContent called.");
            console.log("Current zoom level:", currentZoomLevel);
            console.log("Current pan X, Y:", currentPanX, currentPanY);

            // 1. Get current viewport dimensions
            const viewportWidth = canvasContainer.clientWidth;
            const viewportHeight = canvasContainer.clientHeight;
            console.log("New viewport dimensions:", viewportWidth, viewportHeight);

            // 2. Calculate the current center point of the viewport in screen coordinates
            const screenCenterX = viewportWidth / 2;
            const screenCenterY = viewportHeight / 2;
            console.log("New screen center:", screenCenterX, screenCenterY);

            // 3. Convert these screen coordinates to content coordinates (relative to the full image, before pan/zoom)
            // This is the point on the image that was in the center of the viewport
            const contentCenterX = (screenCenterX - currentPanX) / currentZoomLevel;
            const contentCenterY = (screenCenterY - currentPanY) / currentZoomLevel;
            console.log("Content point that was in center:", contentCenterX, contentCenterY);

            // 4. Calculate new pan values to place that content point back in the center of the NEW viewport
            let newPanX = screenCenterX - (contentCenterX * currentZoomLevel);
            let newPanY = screenCenterY - (contentCenterY * currentZoomLevel);
            
            // Apply clamping for newPanX and newPanY
            const totalGridWidth = Math.ceil(imgGlobal.width / baseTileSize) * baseTileSize;
            const totalGridHeight = Math.ceil(imgGlobal.height / baseTileSize) * baseTileSize;

            const minPanX = viewportWidth - (totalGridWidth * currentZoomLevel);
            const maxPanX = 0;
            const minPanY = viewportHeight - (totalGridHeight * currentZoomLevel);
            const maxPanY = 0;

            // If content is smaller than viewport, center it
            if (totalGridWidth * currentZoomLevel < viewportWidth) {
                newPanX = (viewportWidth - totalGridWidth * currentZoomLevel) / 2;
            } else {
                newPanX = Math.max(minPanX, Math.min(maxPanX, newPanX));
            }

            if (totalGridHeight * currentZoomLevel < viewportHeight) {
                newPanY = (viewportHeight - totalGridHeight * currentZoomLevel) / 2;
            } else {
                newPanY = Math.max(minPanY, Math.min(maxPanY, newPanY));
            }

            currentPanX = newPanX;
            currentPanY = newPanY;

            console.log("Recalculated pan X, Y (after clamping):", currentPanX, currentPanY);

            applyTransform(currentZoomLevel, currentPanX, currentPanY);
            renderTiles(imgGlobal); // Re-render visible tiles if needed

            updateZoomButtonStates();
            updateFitButtonFunctionality();
            updateHomeButtonIcon();
            updateHomeButtonState();
        }

        // Function to adjust layout based on panel and zoom controls state
        function adjustLayout() {
            const isSymbolsPanelOpen = symbolsIframeContainer.classList.contains('open');
            const isZoomControlsExpanded = zoomControlsExpanded.classList.contains('expanded');

            let panelWidth = 0;
            const buttonMargin = 20; // Margin from the right edge for button-controls
            const zoomButtonDefaultWidth = 48; // Default mobile button width

            // Handle symbols panel width
            if (isSymbolsPanelOpen) {
                if (isMobileView()) {
                    // In mobile view, symbols panel width is screen width - zoomModeBtn width - 2 * margin
                    panelWidth = window.innerWidth - zoomButtonDefaultWidth - (2 * buttonMargin);
                    panelWidth = Math.max(panelWidth, 280); // Ensure it doesn't get too small
                    symbolsIframeContainer.style.width = `${panelWidth}px`;
                } else {
                    // Desktop view
                    symbolsIframeContainer.style.width = '30vw';
                    if (symbolsIframeContainer.offsetWidth > 400) {
                        symbolsIframeContainer.style.width = '400px';
                    }
                    panelWidth = symbolsIframeContainer.offsetWidth;
                }
            }

            // Adjust canvasContainer width and buttonControls position
            canvasContainer.style.width = isSymbolsPanelOpen ? `calc(100% - ${panelWidth}px)` : '100%';
            buttonControls.style.right = isSymbolsPanelOpen ? `${buttonMargin + panelWidth}px` : `${buttonMargin}px`;

            // Handle visibility and layout of zoom controls based on screen size and touch
            if (isMobileView()) {
                zoomModeBtn.style.display = 'flex'; // Show zoomModeBtn on mobile
                // Order is now handled by CSS `order` property
                if (isZoomControlsExpanded) {
                    zoomControlsExpanded.style.display = 'flex';
                    zoomControlsExpanded.style.opacity = 1;
                    zoomControlsExpanded.style.pointerEvents = 'auto';
                    zoomControlsExpanded.style.transform = 'translateY(0)';
                } else {
                    zoomControlsExpanded.style.opacity = 0;
                    zoomControlsExpanded.style.pointerEvents = 'none';
                    zoomControlsExpanded.style.transform = 'translateY(20px)';
                    zoomControlsExpanded.addEventListener('transitionend', function handler() {
                        if (!zoomControlsExpanded.classList.contains('expanded')) {
                            zoomControlsExpanded.style.display = 'none';
                        }
                        zoomControlsExpanded.removeEventListener('transitionend', handler);
                    });
                }
            } else {
                // Desktop view
                zoomModeBtn.style.display = 'none'; // Hide zoomModeBtn on desktop
                zoomControlsExpanded.style.display = 'flex'; // Always visible on desktop
                zoomControlsExpanded.style.opacity = 1;
                zoomControlsExpanded.style.pointerEvents = 'auto';
                zoomControlsExpanded.style.transform = 'translateY(0)';
                // Reset order for desktop buttons (no explicit order needed as they are in default flow)
            }
        }


        // Функція для завантаження даних про креслення з config.json та заповнення випадаючого списку
        async function loadDrawings() {
            try {
                const response = await fetch(configUrl);
                const config = await response.json();
                
                // Умовне відображення кнопки "Умовні позначення"
                if (config.hasList === true) {
                    symbolsBtn.style.display = 'flex'; // Показати кнопку
                    panelCloseBtn.style.display = 'flex'; // Показати кнопку закриття
                    if (config.hasListUrl) {
                        symbolsIframe.src = config.hasListUrl; // Встановлюємо src для іфрейму
                    }
                } else {
                    symbolsBtn.style.display = 'none'; // Приховати кнопку
                    panelCloseBtn.style.display = 'none'; // Приховати кнопку закриття
                    symbolsIframeContainer.classList.remove('open'); // Закрити панель, якщо вона була відкрита
                    symbolsBtn.classList.remove('active'); // Зняти активний стан з кнопки
                    symbolsBtn.querySelector('img').src = 'https://img.icons8.com/material-sharp/48/737373/list.png';
                    symbolsBtn.setAttribute('aria-label', 'Умовні позначення');
                    symbolsBtn.title = 'Умовні позначення';
                    symbolsIframe.src = ''; // Очищаємо src іфрейму
                }

                if (config && config.drawings && Array.isArray(config.drawings)) {
                    // Очищаємо існуючі опції в прихованому select
                    drawingSelector.innerHTML = ''; 
                    // Очищаємо кастомні опції
                    customSelectOptions.innerHTML = '';

                    config.drawings.forEach((drawing, index) => {
                        // Додаємо опцію до прихованого select
                        const option = document.createElement('option');
                        option.value = drawing.url;
                        option.textContent = drawing.name;
                        drawingSelector.appendChild(option);

                        // Створюємо кнопку для кастомного меню
                        const customOptionButton = document.createElement('button');
                        customOptionButton.classList.add('custom-select-option');
                        customOptionButton.textContent = drawing.name;
                        customOptionButton.dataset.value = drawing.url;
                        customOptionButton.dataset.index = index; // Зберігаємо індекс для синхронізації

                        customOptionButton.addEventListener('click', () => {
                            // Оновлюємо вибране значення в прихованому select
                            drawingSelector.value = drawing.url;
                            // Оновлюємо відображуваний текст
                            selectedValueSpan.textContent = drawing.name;
                            // Закриваємо меню
                            customSelectOptions.classList.remove('open');
                            customSelectDisplay.classList.remove('open');
                            // Викликаємо зміну зображення
                            imageUrl = drawing.url;
                            processImage();

                            // Видаляємо клас 'selected' з усіх кнопок
                            document.querySelectorAll('.custom-select-option').forEach(btn => {
                                btn.classList.remove('selected');
                            });
                            // Додаємо клас 'selected' до вибраної кнопки
                            customOptionButton.classList.add('selected');
                        });
                        customSelectOptions.appendChild(customOptionButton);
                    });

                    // Встановлюємо початкове зображення на перше з конфігурації, якщо є
                    if (config.drawings.length > 0) {
                        imageUrl = config.drawings[0].url;
                        selectedValueSpan.textContent = config.drawings[0].name; // Встановлюємо початковий текст
                        customSelectOptions.children[0].classList.add('selected'); // Позначаємо першу кнопку як вибрану
                        processImage(); // Завантажуємо перше зображення
                    }
                }
            } catch (error) {
                console.error('Помилка завантаження конфігурації креслень:', error);
            }
        }

        // Обробник подій для відкриття/закриття кастомного селектора
        customSelectDisplay.addEventListener('click', () => {
            customSelectOptions.classList.toggle('open');
            customSelectDisplay.classList.toggle('open');
        });

        // Закриття кастомного селектора при кліку поза ним
        document.addEventListener('click', (e) => {
            if (!drawingSelector.parentNode.contains(e.target) && customSelectOptions.classList.contains('open')) {
                customSelectOptions.classList.remove('open');
                customSelectDisplay.classList.remove('open');
            }
        });


        // Обробник подій для зміни вибору у випадаючому списку (для прихованого select, якщо він все ще потрібен для інших цілей)
        drawingSelector.addEventListener('change', (e) => {
            // Цей обробник може бути видалений, якщо вся логіка перенесена на кастомний селектор
            // imageUrl = e.target.value; // Оновлюємо URL зображення
            // processImage(); // Перезавантажуємо зображення
        });

        // Event Listeners
        symbolsBtn.addEventListener('click', () => {
            symbolsIframeContainer.classList.toggle('open');
            symbolsBtn.classList.toggle('active'); // Toggle active state for symbols button

            // Update symbols button icon based on panel state
            if (symbolsIframeContainer.classList.contains('open')) {
                symbolsBtn.querySelector('img').src = 'https://img.icons8.com/material-outlined/48/FFFFFF/delete-sign.png';
                symbolsBtn.setAttribute('aria-label', 'Закрити умовні позначення');
                symbolsBtn.title = 'Закрити умовні позначення';
            } else {
                symbolsBtn.querySelector('img').src = 'https://img.icons8.com/material-sharp/48/737373/list.png';
                symbolsBtn.setAttribute('aria-label', 'Умовні позначення');
                symbolsBtn.title = 'Умовні позначення';
            }
            requestAnimationFrame(() => {
                adjustLayout(); // Adjust layout after panel state changes
                // recenterMapContent(); // Removed as per user request
            });
        });

        panelCloseBtn.addEventListener('click', () => {
            symbolsIframeContainer.classList.remove('open');
            symbolsBtn.classList.remove('active');
            symbolsBtn.querySelector('img').src = 'https://img.icons8.com/material-sharp/48/737373/list.png';
            symbolsBtn.setAttribute('aria-label', 'Умовні позначення');
            symbolsBtn.title = 'Умовні позначення';
            requestAnimationFrame(() => {
                adjustLayout(); // Adjust layout after panel state changes
                // recenterMapContent(); // Removed as per user request
            });
        });

        zoomModeBtn.addEventListener('click', () => {
            zoomControlsExpanded.classList.toggle('expanded');
            // Toggle icon of zoomModeBtn
            const zoomModeImg = zoomModeBtn.querySelector('img');
            if (zoomControlsExpanded.classList.contains('expanded')) {
                zoomModeImg.src = 'https://img.icons8.com/material-outlined/48/737373/multiply.png'; // Example 'X' icon
                zoomModeBtn.setAttribute('aria-label', 'Закрити елементи керування масштабуванням');
                zoomModeBtn.title = 'Закрити елементи керування масштабуванням';
            } else {
                zoomModeImg.src = 'https://img.icons8.com/fluency-systems-regular/48/737373/zoom-mode.png';
                zoomModeBtn.setAttribute('aria-label', 'Розгорнути елементи керування масштабуванням');
                zoomModeBtn.title = 'Розгорнути елементи керування масштабуванням';
            }
            requestAnimationFrame(adjustLayout); // Only adjust layout, do not recenter map content
        });

        window.addEventListener('resize', () => {
            if (imgGlobal) {
                adjustLayout(); // Use the unified adjustLayout function
                recenterMapContent(); // Recenter map content due to window resize
                if (!loadingBackgroundCanvas.classList.contains('hide-loading')) {
                    drawLoadingBackground(imgGlobal);
                }
            }
        });

        // Initial call on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            loadDrawings().then(() => {
                adjustLayout(); // Initial layout adjustment after drawings are loaded
                recenterMapContent(); // Initial recentering of map content
            });
        });
    </script>
</body>
</html>
